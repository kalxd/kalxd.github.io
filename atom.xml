<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>我的网站</title>
    <link href="127.0.0.1/atom.xml" rel="self" />
    <link href="127.0.0.1" />
    <id>127.0.0.1/atom.xml</id>
    <author>
        <name>我的网站</name>
        <email></email>
    </author>
    <updated>2020-11-26T00:00:00Z</updated>
    <entry>
    <title>Rust与Redis与锁</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/Rust/2020-11-26-concurrent-redis.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/Rust/2020-11-26-concurrent-redis.html</id>
    <published>2020-11-26T00:00:00Z</published>
    <updated>2020-11-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>Rust与Redis与锁</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../css/aono.css">
	<link rel="stylesheet" href="../../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../../index.html">首页</a></li>
				<li class="item"><a href="../../猫.html">分类</a></li>
				<li class="item"><a href="../../标签.html">标签</a></li>
			</ul>

			<a href="../../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				Rust与Redis与锁
				<small class="post date">
					-
					<time datetime="2020-11-26">2020年11月26日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../../%E6%A0%87%E7%AD%BE/Redis.html">Redis</a>, <a href="../../%E6%A0%87%E7%AD%BE/%E5%B9%B6%E5%8F%91.html">并发</a>
		</header>
		<hr>
        <p>Rust提供了非常丰富的锁，用以解决并发时产生的数据竞争等问题。随着应用的增大，外部服务依赖也随之增涨，标准库提供的锁已经发挥不了过多作用——它们仅能应用于单机——面对分布式略有些乏力。为了解决这一问题，我们可以利用Redis一些原子性操作实现一个分布式锁。</p>
<h2 id="基本数据结构">基本数据结构</h2>
<p>在看问题之前，我们定义几个必要的类型：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">use</span> <span class="pp">redis::</span><span class="op">{</span><span class="kw">self</span>, AsyncCommands, Client, RedisResult<span class="op">}</span>;</a>
<a class="sourceLine" id="cb1-2" title="2"> </a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">// 键名。</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">const</span> RKEY: &amp;<span class="ot">'static</span> <span class="dt">str</span> = <span class="st">&quot;my-money&quot;</span>;</a>
<a class="sourceLine" id="cb1-5" title="5"> </a>
<a class="sourceLine" id="cb1-6" title="6"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">)]</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">struct</span> RClient <span class="op">{</span></a>
<a class="sourceLine" id="cb1-8" title="8">    client: Client,</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-10" title="10"> </a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">impl</span> RClient <span class="op">{</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="kw">fn</span> new() -&gt; RedisResult&lt;<span class="kw">Self</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="pp">Client::</span>open(<span class="st">&quot;redis://192.168.1.10&quot;</span>).map(|client| RClient <span class="op">{</span> client <span class="op">}</span>)</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-15" title="15"> </a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="co">// 初始最开始钱包。</span></a>
<a class="sourceLine" id="cb1-17" title="17">	<span class="co">// 每次启动程序时，都要初始化这个值。</span></a>
<a class="sourceLine" id="cb1-18" title="18">    async <span class="kw">fn</span> init_data(&amp;<span class="kw">self</span>) -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="kw">self</span>.set_money(<span class="dv">100</span>).await</a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-21" title="21"> </a>
<a class="sourceLine" id="cb1-22" title="22">    <span class="co">// 设置金钱。</span></a>
<a class="sourceLine" id="cb1-23" title="23">    async <span class="kw">fn</span> set_money(&amp;<span class="kw">self</span>, money: <span class="dt">u32</span>) -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb1-24" title="24">        <span class="kw">let</span> <span class="kw">mut</span> conn = <span class="kw">self</span>.client.get_async_connection().await?;</a>
<a class="sourceLine" id="cb1-25" title="25">        conn.set(RKEY, money).await</a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-27" title="27"> </a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="co">// 得到余额。</span></a>
<a class="sourceLine" id="cb1-29" title="29">    async <span class="kw">fn</span> get_money(&amp;<span class="kw">self</span>) -&gt; RedisResult&lt;<span class="dt">u32</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb1-30" title="30">        <span class="kw">let</span> <span class="kw">mut</span> conn = <span class="kw">self</span>.client.get_async_connection().await?;</a>
<a class="sourceLine" id="cb1-31" title="31">        <span class="kw">let</span> x: <span class="dt">u32</span> = conn.get(RKEY).await?;</a>
<a class="sourceLine" id="cb1-32" title="32">        <span class="cn">Ok</span>(x)</a>
<a class="sourceLine" id="cb1-33" title="33">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="op">}</span></a></code></pre></div>
<p><code>RClient</code>相当于<code>Redis::Client</code>，封装了几个我们以后会用到的常用功能。</p>
<h2 id="问题背景">问题背景</h2>
<p>假设这样一个场景，一个用户余额100元，分别下了10单，每单价格10元，刚好能花完。我们假设这10单处理时间十分相近，约等价于：</p>
<div class="两栏">
<div class="列">
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" title="1"><span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></a>
<a class="sourceLine" id="cb2-2" title="2">async <span class="kw">fn</span> main() -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">use</span> <span class="pp">futures::stream::</span><span class="op">{</span><span class="kw">self</span>, StreamExt<span class="op">}</span>;</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">let</span> client = <span class="pp">RClient::</span>new()?;</a>
<a class="sourceLine" id="cb2-6" title="6">    client.init_data().await?;</a>
<a class="sourceLine" id="cb2-7" title="7"> </a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="pp">stream::</span>iter(<span class="dv">1</span>..<span class="dv">11</span>)</a>
<a class="sourceLine" id="cb2-9" title="9">        .for_each_concurrent(<span class="cn">None</span>, |n| <span class="op">{</span></a>
<a class="sourceLine" id="cb2-10" title="10">            <span class="kw">let</span> client = client.clone();</a>
<a class="sourceLine" id="cb2-11" title="11">            async <span class="kw">move</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-12" title="12">                <span class="pp">println!</span>(<span class="st">&quot;第{:?}任务&quot;</span>, n);</a>
<a class="sourceLine" id="cb2-13" title="13">                <span class="kw">let</span> money = client.get_money().await.unwrap();</a>
<a class="sourceLine" id="cb2-14" title="14">                <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, money);</a>
<a class="sourceLine" id="cb2-15" title="15">                client.set_money(money - <span class="dv">10</span>).await.unwrap();</a>
<a class="sourceLine" id="cb2-16" title="16">            <span class="op">}</span></a>
<a class="sourceLine" id="cb2-17" title="17">        <span class="op">}</span>)</a>
<a class="sourceLine" id="cb2-18" title="18">        .await;</a>
<a class="sourceLine" id="cb2-19" title="19"> </a>
<a class="sourceLine" id="cb2-20" title="20">    <span class="kw">let</span> money = client.get_money().await?;</a>
<a class="sourceLine" id="cb2-21" title="21">    <span class="pp">println!</span>(<span class="st">&quot;最后金额：{:?}&quot;</span>, money);</a>
<a class="sourceLine" id="cb2-22" title="22"> </a>
<a class="sourceLine" id="cb2-23" title="23">    <span class="cn">Ok</span>(())</a>
<a class="sourceLine" id="cb2-24" title="24"><span class="op">}</span></a></code></pre></div>
</div>
<div class="列">
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">第<span class="ex">1</span>任务</a>
<a class="sourceLine" id="cb3-2" title="2">第<span class="ex">2</span>任务</a>
<a class="sourceLine" id="cb3-3" title="3">第<span class="ex">3</span>任务</a>
<a class="sourceLine" id="cb3-4" title="4">第<span class="ex">4</span>任务</a>
<a class="sourceLine" id="cb3-5" title="5">第<span class="ex">5</span>任务</a>
<a class="sourceLine" id="cb3-6" title="6">第<span class="ex">6</span>任务</a>
<a class="sourceLine" id="cb3-7" title="7">第<span class="ex">7</span>任务</a>
<a class="sourceLine" id="cb3-8" title="8">第<span class="ex">8</span>任务</a>
<a class="sourceLine" id="cb3-9" title="9">第<span class="ex">9</span>任务</a>
<a class="sourceLine" id="cb3-10" title="10">第<span class="ex">10</span>任务</a>
<a class="sourceLine" id="cb3-11" title="11"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-15" title="15"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-19" title="19"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-20" title="20"><span class="ex">100</span></a>
<a class="sourceLine" id="cb3-21" title="21">最后金额：<span class="ex">90</span></a></code></pre></div>
</div>
</div>
<p>明明下了10单，却只扣了一份的钱，我们可以看到输出多个<code>100</code>，这是在获取用户余额。由于多个任务同时进行，在用户扣除费用之前就去获取途额，最后得到的是扣除前的余额，错误的余额导致错误的结果。</p>
<h2 id="简单锁">简单锁</h2>
<p>实现锁就需要一些原子性操作，Redis恰好提供了<a href="https://redis.io/commands/setnx">setnx</a><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、<a href="https://redis.io/commands/setex">setex</a><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>，这是我们实现分布式锁的前提。</p>
<p>一个扣费请求可以如下表述：</p>
<ol type="1">
<li>发起扣费请求。</li>
<li>请求加琐。</li>
<li>请求失败，重试步骤2。</li>
<li>请求成功，获取余额，计算并保存。</li>
<li>释放锁。</li>
</ol>
<p>用流程图表示如下：</p>
<figure>
<img src="../../image/扣费加锁流程.jpg" alt="扣费加锁流程" /><figcaption>扣费加锁流程</figcaption>
</figure>
<p>多个扣费请求一同发起，也会因为无法获得锁而处于等待的状态，只有上个任务完成、释放出锁，才能进行下一步。我们好像实现了一个分布式Mutex琐。</p>
<p>接下来我们为<code>RClient</code>实现加琐、解锁方法：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">impl</span> RClient <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    async <span class="kw">fn</span> try_lock(&amp;<span class="kw">self</span>) -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="kw">let</span> <span class="kw">mut</span> conn = <span class="kw">self</span>.client.get_async_connection().await?;</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" title="5">            <span class="kw">if</span> conn.set_nx(LOCK_KEY, <span class="dv">1</span>).await? <span class="op">{</span></a>
<a class="sourceLine" id="cb4-6" title="6">                <span class="kw">return</span> <span class="cn">Ok</span>(());</a>
<a class="sourceLine" id="cb4-7" title="7">            <span class="op">}</span></a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="op">}</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-10" title="10"> </a>
<a class="sourceLine" id="cb4-11" title="11">    async <span class="kw">fn</span> unlock(&amp;<span class="kw">self</span>) -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb4-12" title="12">        <span class="kw">let</span> <span class="kw">mut</span> conn = <span class="kw">self</span>.client.get_async_connection().await?;</a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-14" title="14">            <span class="kw">if</span> conn.del(LOCK_KEY).await? <span class="op">{</span></a>
<a class="sourceLine" id="cb4-15" title="15">                <span class="kw">return</span> <span class="cn">Ok</span>(());</a>
<a class="sourceLine" id="cb4-16" title="16">            <span class="op">}</span></a>
<a class="sourceLine" id="cb4-17" title="17">        <span class="op">}</span></a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>再改一改main函数：</p>
<div class="两栏">
<div class="列">
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb5-1" title="1"><span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></a>
<a class="sourceLine" id="cb5-2" title="2">async <span class="kw">fn</span> main() -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">use</span> <span class="pp">futures::stream::</span><span class="op">{</span><span class="kw">self</span>, StreamExt<span class="op">}</span>;</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">let</span> client = <span class="pp">RClient::</span>new()?;</a>
<a class="sourceLine" id="cb5-6" title="6">    client.init_data().await?;</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="pp">stream::</span>iter(<span class="dv">1</span>..<span class="dv">11</span>)</a>
<a class="sourceLine" id="cb5-9" title="9">        .for_each_concurrent(<span class="cn">None</span>, |n| <span class="op">{</span></a>
<a class="sourceLine" id="cb5-10" title="10">            <span class="kw">let</span> client = client.clone();</a>
<a class="sourceLine" id="cb5-11" title="11">            async <span class="kw">move</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-12" title="12">                <span class="pp">println!</span>(<span class="st">&quot;第{:?}任务&quot;</span>, n);</a>
<a class="sourceLine" id="cb5-13" title="13"></a>
<a class="sourceLine" id="cb5-14" title="14">                <span class="co">// 加琐。</span></a>
<a class="sourceLine" id="cb5-15" title="15">                client.try_lock().await.unwrap();</a>
<a class="sourceLine" id="cb5-16" title="16">                <span class="kw">let</span> money = client.get_money().await.unwrap();</a>
<a class="sourceLine" id="cb5-17" title="17">                <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, money);</a>
<a class="sourceLine" id="cb5-18" title="18">                client.set_money(money - <span class="dv">10</span>).await.unwrap();</a>
<a class="sourceLine" id="cb5-19" title="19"></a>
<a class="sourceLine" id="cb5-20" title="20">                <span class="co">// 解锁。</span></a>
<a class="sourceLine" id="cb5-21" title="21">                client.unlock().await.unwrap();</a>
<a class="sourceLine" id="cb5-22" title="22">            <span class="op">}</span></a>
<a class="sourceLine" id="cb5-23" title="23">        <span class="op">}</span>)</a>
<a class="sourceLine" id="cb5-24" title="24">        .await;</a>
<a class="sourceLine" id="cb5-25" title="25"></a>
<a class="sourceLine" id="cb5-26" title="26">    <span class="kw">let</span> money = client.get_money().await?;</a>
<a class="sourceLine" id="cb5-27" title="27">    <span class="pp">println!</span>(<span class="st">&quot;最后金额：{:?}&quot;</span>, money);</a>
<a class="sourceLine" id="cb5-28" title="28"></a>
<a class="sourceLine" id="cb5-29" title="29">    <span class="cn">Ok</span>(())</a>
<a class="sourceLine" id="cb5-30" title="30"><span class="op">}</span></a></code></pre></div>
</div>
<div class="列">
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">第<span class="ex">1</span>任务</a>
<a class="sourceLine" id="cb6-2" title="2">第<span class="ex">2</span>任务</a>
<a class="sourceLine" id="cb6-3" title="3">第<span class="ex">3</span>任务</a>
<a class="sourceLine" id="cb6-4" title="4">第<span class="ex">4</span>任务</a>
<a class="sourceLine" id="cb6-5" title="5">第<span class="ex">5</span>任务</a>
<a class="sourceLine" id="cb6-6" title="6">第<span class="ex">6</span>任务</a>
<a class="sourceLine" id="cb6-7" title="7">第<span class="ex">7</span>任务</a>
<a class="sourceLine" id="cb6-8" title="8">第<span class="ex">8</span>任务</a>
<a class="sourceLine" id="cb6-9" title="9">第<span class="ex">9</span>任务</a>
<a class="sourceLine" id="cb6-10" title="10">第<span class="ex">10</span>任务</a>
<a class="sourceLine" id="cb6-11" title="11"><span class="ex">100</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="ex">90</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="ex">80</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="ex">70</span></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="ex">60</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="ex">50</span></a>
<a class="sourceLine" id="cb6-17" title="17"><span class="ex">40</span></a>
<a class="sourceLine" id="cb6-18" title="18"><span class="ex">30</span></a>
<a class="sourceLine" id="cb6-19" title="19"><span class="ex">20</span></a>
<a class="sourceLine" id="cb6-20" title="20"><span class="ex">10</span></a>
<a class="sourceLine" id="cb6-21" title="21">最后金额：<span class="ex">0</span></a></code></pre></div>
</div>
</div>
<p>代码与最开始一版并不多，但这里已经能正确用户余额了，最后也得到了正确结果。</p>
<h2 id="超时琐">超时琐</h2>
<p>我们已经实现了一个简易锁，正常情况下用起来十分不错，结果也都正确。但再仔细观察观察，容易发现一个问题，如果一个请求占据了这个锁，运行中途突然中断（也可能任务中断，也可以有出现异常），导致锁一直无法释放。后面所有请求都会尝试获取一个永远得不到的锁，也就是出现了死锁。这样的情况是不能出现的，为此，我们在加锁时，需要为锁添加一个超时时间，避免占用时间无限导致死锁。</p>
<p>为了简化，默认超时时间都为<strong>一秒</strong>。我们只需要简单改改加锁方法即可：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb7-1" title="1">async <span class="kw">fn</span> try_lock(&amp;<span class="kw">self</span>) -&gt; RedisResult&lt;()&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">let</span> <span class="kw">mut</span> conn = <span class="kw">self</span>.client.get_async_connection().await?;</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">        <span class="kw">if</span> conn.set_nx(LOCK_KEY, <span class="dv">1</span>).await? <span class="op">{</span></a>
<a class="sourceLine" id="cb7-5" title="5">            conn.expire(LOCK_KEY, <span class="dv">1</span>).await?;</a>
<a class="sourceLine" id="cb7-6" title="6">            <span class="kw">return</span> <span class="cn">Ok</span>(());</a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="op">}</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>当我们加锁成功时，将它赋一个超时属性。解锁逻辑依旧。 这样我们就不用担心锁因中断而无法释放的问题了。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>“SET if Not eXists”的缩写，返回值表示不同情况：返回1时，表示值不存在，set成功；返回0时，表示值已存在，不做任何操作。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>原子性操作，set时并添加超时属性。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>
<entry>
    <title>Y不动点组合子流水帐</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/Racket/2020-08-05-Y-fixed-combinator.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/Racket/2020-08-05-Y-fixed-combinator.html</id>
    <published>2020-08-05T00:00:00Z</published>
    <updated>2020-08-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>Y不动点组合子流水帐</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../css/aono.css">
	<link rel="stylesheet" href="../../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../../index.html">首页</a></li>
				<li class="item"><a href="../../猫.html">分类</a></li>
				<li class="item"><a href="../../标签.html">标签</a></li>
			</ul>

			<a href="../../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				Y不动点组合子流水帐
				<small class="post date">
					-
					<time datetime="2020-08-05">2020年08月05日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../../%E6%A0%87%E7%AD%BE/Racket.html">Racket</a>, <a href="../../%E6%A0%87%E7%AD%BE/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80.html">程序语言</a>
		</header>
		<hr>
        <h2 id="y组合子">Y组合子</h2>
<blockquote>
<p>Y组合子是 lambda 演算中的一个概念，是任意函数的不动点，在函数式编程中主要作用是<strong>提供一种匿名函数的递归方式</strong>。</p>
</blockquote>
<p>Y组合子表达式：</p>
<p><br /><span class="math display"><em>λ</em><em>f</em>. (<em>λ</em><em>x</em>. <em>f</em>(<em>x</em> <em>x</em>))(<em>λ</em><em>x</em>. <em>f</em>(<em>x</em> <em>x</em>))</span><br /></p>
<h2 id="递归匿名函数">递归匿名函数</h2>
<p>这里有个递归版本的求和函数：</p>
<pre class="racket"><code>(define (sum n)
  (if (= n 0)
      n
      (+ n (sum (- n 1)))))

(sum 10)
; 10</code></pre>
<p>大道至简，一目了然。<code>sum</code>内调用了自身，因为它已具名，那么匿名函数又将如何递归呢？</p>
<h2 id="失败的尝试">失败的尝试</h2>
<p>我们移除<code>sum</code>之后会如何？</p>
<pre class="racket"><code>(λ (n)
  (if (= n 0)
      n
      (+ n (?f (- n 1)))))</code></pre>
<p>连函数定义都不完整了，<code>?f</code>未定义，看来这样写不行。</p>
<h2 id="穷人的尝试">穷人的尝试</h2>
<blockquote>
<p>任何问题都可以通过增加一个间接层来解决。</p>
</blockquote>
<p>我们增加一个参数：</p>
<pre class="racket"><code>(λ (f n)
  (if (= n 0)
      n
      (+ n (f f (- n 1)))))</code></pre>
<p>函数定义完成，<code>f</code>即自身。但如何调用呢？它连名字都没有。我们暂时赋予它一个名字，试着调用：</p>
<pre class="racket"><code>(define P (λ (f n)
  (if (= n 0)
      n
      (+ n (f f (- n 1))))))
(P P 10)
; 55</code></pre>
<p>我们可以看到<code>P</code>和<code>f</code>并不关联，换句话说，<code>P</code>完全可以被替换掉：</p>
<pre class="racket"><code>((λ (f n)
  (if (= n 0)
      n
      (+ n (f f (- n 1)))))
 (λ (f n)
  (if (= n 0)
      n
      (+ n (f f (- n 1)))))
 5)
 ; 15</code></pre>
<h2 id="y组合子定义">Y组合子定义</h2>
<p>定义推导已经很多版本了<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。这里直接给出定义：</p>
<div class="两栏">
<div class="列">
<p>严格版：</p>
<pre class="racket"><code>#lang racket/base

(define (Y f)
  (let ([g (λ (x) (x x))]
        [h (λ (y) (f (λ (x) ((y y) x))))])
    (g h)))

(define sum
  (Y (λ (f)
       (λ (n)
         (if (= n 0)
             n
             (+ n (f (- n 1))))))))
(sum 5)
; 15</code></pre>
</div>
<div class="列">
<p>惰性版：</p>
<pre class="racket"><code>#lang lazy

(define Y (λ (f) ((λ (x) (f (x x))) (λ (x) (f (x x))))))

(define sum
  (Y (λ (f)
       (λ (n)
         (if (= n 0)
             n
             (+ n (f (- n 1))))))))

(sum 10)
; 10</code></pre>
</div>
</div>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/21099081">Y不动点组合子用在哪里？</a></li>
<li><a href="https://blog.csdn.net/pongba/article/details/1336028">康托尔、哥德尔、图灵——永恒的金色对角线(rev#2)</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion">Haskell/Fix and recursion</a></li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://segmentfault.com/a/1190000008212076">Javascript 中 Y 组合子的推导 - 一隅 - SegmentFault 思否</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>
<entry>
    <title>Javascript函数式设计总结</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/2020-07-26-js-fp.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/2020-07-26-js-fp.html</id>
    <published>2020-07-26T00:00:00Z</published>
    <updated>2020-07-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>Javascript函数式设计总结</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../css/aono.css">
	<link rel="stylesheet" href="../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../index.html">首页</a></li>
				<li class="item"><a href="../猫.html">分类</a></li>
				<li class="item"><a href="../标签.html">标签</a></li>
			</ul>

			<a href="../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				Javascript函数式设计总结
				<small class="post date">
					-
					<time datetime="2020-07-26">2020年07月26日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../%E6%A0%87%E7%AD%BE/%E8%AE%BE%E8%AE%A1.html">设计</a>
		</header>
		<hr>
        <div class="toc">目录：<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#函数式优点">函数式优点</a><ul>
<li><a href="#隔离副作用">隔离副作用</a></li>
<li><a href="#强调组合">强调组合</a></li>
</ul></li>
<li><a href="#ramda">ramda</a></li>
<li><a href="#函数签名说明">函数签名说明</a><ul>
<li><a href="#promise">Promise</a></li>
<li><a href="#自定义类型">自定义类型</a></li>
</ul></li>
<li><a href="#一些问题的设计方案">一些问题的设计方案</a><ul>
<li><a href="#组合promise">组合Promise</a></li>
<li><a href="#自定义类型hits">自定义类型——Hits</a></li>
</ul></li>
<li><a href="#更多可能性">更多可能性</a></li>
<li><a href="#结语">结语</a></li>
</ul></div><h2 id="前言">前言</h2>
<p>随着<a href="https://github.com/kalxd/drifloon">drifloon</a>日渐稳定，除了浏览器领域，我使用JS的范围逐渐狭小，决定总结函数式JS一些设计思路。</p>
<p>总的来说用JS写函数式代码，是件吃力不讨好的事，不仅性能差，而且与JS本身设计相背离——JS本身不是严格函数式，它的基础设施也不是函数式。</p>
<h2 id="函数式优点">函数式优点</h2>
<p>这里函数式指<strong>纯</strong>函数式，我有两个非常重要的体会：</p>
<ul>
<li>隔离副作用</li>
<li>强调组合</li>
</ul>
<h3 id="隔离副作用">隔离副作用</h3>
<p>函数式并不要求不能有副作用，而是能做到好的隔离。Haskell有类型做保护，动态类型的JS只能靠自我约束。 隔离出副作用，提高函数的纯度，能更好预见函数行为，对于纯函数而言，一个确定输入，总能得到确定输出，不会随时间、状态的改变而改变。</p>
<p>假设我们实现“加一”函数：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">const</span> inc <span class="op">=</span> x <span class="kw">=&gt;</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a></code></pre></div>
<p><code>inc(1)</code>永远等于<code>2</code>，无论何时调用都是如此。假如加个随机数：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> inc <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">	<span class="cf">if</span> (<span class="va">Math</span>.<span class="at">random</span>() <span class="op">&lt;</span> <span class="fl">0.5</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">		<span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4">	<span class="op">}</span></a>
<a class="sourceLine" id="cb2-5" title="5">	<span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">		<span class="cf">return</span> x <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7">	<span class="op">}</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="op">};</span></a></code></pre></div>
<p>这个函数就变得不纯，<code>inc(1)</code>下个值无法确，可能是2，也可能是1。所以我们可以将不纯部分——<code>Math.random</code>——分隔开：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">const</span> inc <span class="kw">=&gt;</span> x <span class="kw">=&gt;</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">const</span> isLessIO <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="va">Math</span>.<span class="at">random</span>() <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">const</span> incIO <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-6" title="6">	<span class="cf">if</span> (<span class="at">isLessIO</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-7" title="7">		<span class="cf">return</span> <span class="at">inc</span>(x)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-8" title="8">	<span class="op">}</span></a>
<a class="sourceLine" id="cb3-9" title="9">	<span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-10" title="10">		<span class="cf">return</span> x <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-11" title="11">	<span class="op">}</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="op">};</span></a></code></pre></div>
<p>这里拆分成三个函数，<code>inc</code>作为纯函数单独提出，它本身行为可预测，将来<code>incIO</code>出错，也只能在<code>isLessIO</code>或本身实现，这将减少调试范围。</p>
<p>同时我们也能看到副作用有传染性，调用到<code>isLessIO</code>的函数本身也有副作用。</p>
<h3 id="强调组合">强调组合</h3>
<p>说到函数组合很容易想到<code>compose</code>。其实计算机就是组合的典范，内部分成CPU、内存、硬盘……每个部分职责分明，最后组合成一台功能完善的电脑。我们写程序也是如此，分解成一个一个小问题，最后再组合起来解决一个大问题——这就是KISS原则。 我们看上面例子，我们将原本一个大函数分成若干小函数，每个小函数只解决自己的问题，最终再合起来变成<code>incIO</code>。</p>
<p>这样分解过程，同时也是做抽象的过程，例如我们可以这样思考<code>incIO</code>：它根据<code>isLessIO</code>的值判断调用哪个函数，那么我们甚至可以这样写：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">const</span> incIO <span class="op">=</span> <span class="va">R</span>.<span class="at">ifElse</span>(</a>
<a class="sourceLine" id="cb4-2" title="2">	isLessIO<span class="op">,</span></a>
<a class="sourceLine" id="cb4-3" title="3">	<span class="va">R</span>.<span class="at">inc</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-4" title="4">	<span class="va">R</span>.<span class="at">dec</span></a>
<a class="sourceLine" id="cb4-5" title="5">)<span class="op">;</span></a></code></pre></div>
<p><code>R</code>即<em>ramda.js</em>，整条代码清晰了明，同时也能看到，高阶函数也是能做组合。</p>
<h2 id="ramda">ramda</h2>
<p>上面提到了<a href="https://github.com/Ramda/ramda">ramda</a>，它有几个与众不同的特性：</p>
<ul>
<li>柯里化</li>
<li>正确的参数位置</li>
<li>透镜</li>
<li>不可变</li>
</ul>
<p><em>柯里化</em>不再受<em>不定长参数</em>、<em>关键字参数</em>困扰，后者不仅调用成本高，而且编写难度大——处理这些参数也写不少代码； <strong>正确的参数位置</strong>能保证调用的顺滑度，不再费劲儿地写出每个参数； <em>透镜</em>概念来自<a href="https://www.stackage.org/package/lens">Haskell Lens库</a>，为不同数组结构操作统一接口，同时具有组合性； <strong>不可变</strong>指ramda提供的都是纯函数，ramda甚至连随机数都没有。</p>
<p>我们可以看一段代表性的代码：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> f <span class="op">=</span> <span class="va">R</span>.<span class="at">compose</span>(</a>
<a class="sourceLine" id="cb5-2" title="2">	<span class="va">R</span>.<span class="at">join</span>(<span class="st">&quot;&amp;&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb5-3" title="3">	<span class="va">R</span>.<span class="at">map</span>(<span class="va">R</span>.<span class="at">join</span>(<span class="st">&quot;=&quot;</span>))<span class="op">,</span></a>
<a class="sourceLine" id="cb5-4" title="4">	<span class="va">R</span>.<span class="at">toPairs</span></a>
<a class="sourceLine" id="cb5-5" title="5">)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="at">f</span>(<span class="op">{</span><span class="dt">q</span><span class="op">:</span> <span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="dt">pos</span><span class="op">:</span> <span class="dv">1</span><span class="op">}</span>))<span class="op">;</span> <span class="co">// q=hello&amp;pos=1</span></a></code></pre></div>
<div class="注意">
<p>ramda.js仅对原始类型有效，用户自定义类型恐难胜任。</p>
</div>
<h2 id="函数签名说明">函数签名说明</h2>
<p>下面尽量标出每个函数类型签名，写法与Haskell类似，由于JS是动态语言，一个函数甚至可以接受不同类型参数，这在写法上有些困难，不管怎样，我们都将做一个规范。</p>
<p>一个普通的例子：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// Int -&gt; Int -&gt; Int</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> add <span class="op">=</span> <span class="va">R</span>.<span class="at">curry</span>((x<span class="op">,</span> y) <span class="kw">=&gt;</span> x <span class="op">+</span> y)<span class="op">;</span></a></code></pre></div>
<p>类型与Haskell类似，但省略了函数名。</p>
<h3 id="promise">Promise</h3>
<p>总觉得Promise与Either十分类似，我们可以采用类似写法：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">add ::</span> <span class="dt">Promise</span> e <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Promise</span> e <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Promise</span> e <span class="dt">Int</span></a></code></pre></div>
<p>当然，如果无关错误<code>e</code>，就简化成<code>type Resolver = Promise e</code>：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">add ::</span> <span class="dt">Resolver</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Resolver</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Resolver</span> <span class="dt">Int</span></a></code></pre></div>
<h3 id="自定义类型">自定义类型</h3>
<p>ramda不支持自定义类型，我们只能按一定格式写object，假装成特定类型——典型的鸭子类型。那时我们需要给出是怎样的object，以及它的表示方法。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> <span class="dt">Person</span> <span class="fu">=</span> {<span class="ot"> name ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-2" title="2">              ,<span class="ot"> age ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-3" title="3">              }</a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">add ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>我们定义了<code>Person</code>的object，它有<code>name</code>和<code>age</code>；只要有<code>name</code>和<code>age</code>的object都可以认作<code>Person</code>。</p>
<h2 id="一些问题的设计方案">一些问题的设计方案</h2>
<h3 id="组合promise">组合Promise</h3>
<p><code>R.compose</code>可以组合同步函数，那么能不能组合Promise呢？ramda给出了<code>andThen</code>，我们可以这样写：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// Int -&gt; Resolver Int</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">const</span> incP <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="va">Promise</span>.<span class="at">resolve</span>(x <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">// Int -&gt; Resolver Int</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">const</span> f <span class="op">=</span> <span class="va">R</span>.<span class="at">compose</span>(</a>
<a class="sourceLine" id="cb10-6" title="6">	<span class="va">R</span>.<span class="at">andThen</span>(incP)<span class="op">,</span></a>
<a class="sourceLine" id="cb10-7" title="7">	<span class="va">R</span>.<span class="at">andThen</span>(<span class="va">R</span>.<span class="at">inc</span>)<span class="op">,</span> <span class="co">// 此处与Promise.then一致，可以返回普通对象，也可以返回Promise。</span></a>
<a class="sourceLine" id="cb10-8" title="8">	incP</a>
<a class="sourceLine" id="cb10-9" title="9">)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="at">f</span>(<span class="dv">1</span>).<span class="at">then</span>(<span class="va">console</span>.<span class="at">log</span>)<span class="op">;</span> <span class="co">// 4</span></a></code></pre></div>
<p>每次写<code>R.andThen</code>还是有些繁琐，那么能不能连它都能一同省略呢？我们尝试作一个新版本：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// 调用方式与R.pipe一致，接受不定长的函数列表，依次从上而下执行。</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">// 不与R.compose相同，异常阅读顺序从下往下更自然。</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">const</span> composeP <span class="op">=</span> <span class="va">R</span>.<span class="at">unapply</span>(xs <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-5" title="5">	<span class="co">// 已经执行到最后一步，将上个结果直接返回。</span></a>
<a class="sourceLine" id="cb11-6" title="6">	<span class="cf">if</span> (<span class="va">R</span>.<span class="at">isEmpty</span>(xs)) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-7" title="7">		<span class="cf">return</span> <span class="va">R</span>.<span class="at">identity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-8" title="8">	<span class="op">}</span></a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10">	<span class="kw">const</span> [f<span class="op">,</span> ...<span class="at">fs</span>] <span class="op">=</span> xs<span class="op">;</span></a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12">	<span class="cf">return</span> (...<span class="at">args</span>) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-13" title="13">		<span class="kw">const</span> value <span class="op">=</span> <span class="at">f</span>(...<span class="at">args</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-14" title="14"></a>
<a class="sourceLine" id="cb11-15" title="15">		<span class="cf">if</span> (<span class="va">R</span>.<span class="at">is</span>(Promise<span class="op">,</span> value)) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-16" title="16">			<span class="cf">return</span> <span class="va">value</span>.<span class="at">then</span>(<span class="at">composeP</span>(...<span class="at">fs</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb11-17" title="17">		<span class="op">}</span></a>
<a class="sourceLine" id="cb11-18" title="18">		<span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-19" title="19">			<span class="cf">return</span> <span class="at">composeP</span>(...<span class="at">fs</span>)(value)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-20" title="20">		<span class="op">}</span></a>
<a class="sourceLine" id="cb11-21" title="21">	<span class="op">};</span></a>
<a class="sourceLine" id="cb11-22" title="22"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-23" title="23"></a>
<a class="sourceLine" id="cb11-24" title="24"><span class="co">// Int -&gt; Resolver Int</span></a>
<a class="sourceLine" id="cb11-25" title="25"><span class="kw">const</span> f <span class="op">=</span> <span class="at">composeP</span>(<span class="va">R</span>.<span class="at">inc</span><span class="op">,</span> incP<span class="op">,</span> <span class="va">R</span>.<span class="at">inc</span>)<span class="op">;</span> <span class="co">// 中间过程只要产生Promise，结果一定就是Promise。</span></a>
<a class="sourceLine" id="cb11-26" title="26"></a>
<a class="sourceLine" id="cb11-27" title="27"><span class="at">f</span>(<span class="dv">1</span>).<span class="at">then</span>(<span class="va">console</span>.<span class="at">log</span>)<span class="op">;</span> <span class="co">// 4</span></a></code></pre></div>
<p>我们区分<code>value</code>是否是Promise，若是Promise按照Promise方式执行，若不是，按照普通方式执行。<code>composeP</code>同样能组合同步函数：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="co">// Int -&gt; Int</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">const</span> f <span class="op">=</span> <span class="at">composeP</span>(<span class="va">R</span>.<span class="at">inc</span><span class="op">,</span> <span class="va">R</span>.<span class="at">inc</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="at">f</span>(<span class="dv">1</span>)<span class="op">;</span> <span class="co">// 3</span></a></code></pre></div>
<p>空值很讨厌，那么我们是否还能在此基础上再作一版，只要中间任何一步产生空值<code>null</code>，我们就中断后续操作，将返回<code>null</code>？我们改一改原函数：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb13-1" title="1">const composeP = R.unapply(xs =&gt; {</a>
<a class="sourceLine" id="cb13-2" title="2">	// 已经执行到最后一步，将上个结果直接返回。</a>
<a class="sourceLine" id="cb13-3" title="3">	if (R.isEmpty(xs)) {</a>
<a class="sourceLine" id="cb13-4" title="4">		return R.identity;</a>
<a class="sourceLine" id="cb13-5" title="5">	}</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7">	const [f, ...fs] = xs;</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9">	return (...args) =&gt; {</a>
<a class="sourceLine" id="cb13-10" title="10">		const value = f(...args);</a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12">		if (R.is(Promise, value)) {</a>
<a class="sourceLine" id="cb13-13" title="13"><span class="st">-			return value.then(composeP(...fs));</span></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="va">+			return value.then(v =&gt; {</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="va">+				if (R.isNil(v)) {</span></a>
<a class="sourceLine" id="cb13-16" title="16"><span class="va">+					return null;</span></a>
<a class="sourceLine" id="cb13-17" title="17"><span class="va">+				}</span></a>
<a class="sourceLine" id="cb13-18" title="18"><span class="va">+				else {</span></a>
<a class="sourceLine" id="cb13-19" title="19"><span class="va">+					return composeP(...fs)(v);</span></a>
<a class="sourceLine" id="cb13-20" title="20"><span class="va">+				}</span></a>
<a class="sourceLine" id="cb13-21" title="21"><span class="va">+			});</span></a>
<a class="sourceLine" id="cb13-22" title="22">		}</a>
<a class="sourceLine" id="cb13-23" title="23">		else {</a>
<a class="sourceLine" id="cb13-24" title="24"><span class="st">-			return composeP(...fs)(value);</span></a>
<a class="sourceLine" id="cb13-25" title="25"><span class="va">+			if (R.isNil(value)) {</span></a>
<a class="sourceLine" id="cb13-26" title="26"><span class="va">+				return null;</span></a>
<a class="sourceLine" id="cb13-27" title="27"><span class="va">+			}</span></a>
<a class="sourceLine" id="cb13-28" title="28"><span class="va">+			else {</span></a>
<a class="sourceLine" id="cb13-29" title="29"><span class="va">+				return composeP(...fs)(value)</span></a>
<a class="sourceLine" id="cb13-30" title="30"><span class="va">+			};</span></a>
<a class="sourceLine" id="cb13-31" title="31">		}</a>
<a class="sourceLine" id="cb13-32" title="32">	};</a>
<a class="sourceLine" id="cb13-33" title="33">});</a></code></pre></div>
<p>我们仅对结果稍加判断，如果为空，直接返回，不再执行下去。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// Int -&gt; Resolver (Maybe Int)</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">const</span> incP <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-3" title="3">	<span class="cf">if</span> (x <span class="op">&gt;</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-4" title="4">		<span class="cf">return</span> <span class="va">Promise</span>.<span class="at">resolve</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5">	<span class="op">}</span></a>
<a class="sourceLine" id="cb14-6" title="6">	<span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-7" title="7">		<span class="cf">return</span> <span class="va">Promise</span>.<span class="at">resolve</span>(x <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-8" title="8">	<span class="op">}</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="op">};</span></a>
<a class="sourceLine" id="cb14-10" title="10"></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="co">// Int -&gt; Resolver (Maybe Int)</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="kw">const</span> f <span class="op">=</span> <span class="at">composeP</span>(</a>
<a class="sourceLine" id="cb14-13" title="13">	<span class="va">R</span>.<span class="at">inc</span><span class="op">,</span></a>
<a class="sourceLine" id="cb14-14" title="14">	<span class="va">R</span>.<span class="at">tap</span>(<span class="va">console</span>.<span class="at">log</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb14-15" title="15">	incP<span class="op">,</span></a>
<a class="sourceLine" id="cb14-16" title="16">	<span class="va">R</span>.<span class="at">tap</span>(<span class="va">console</span>.<span class="at">log</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb14-17" title="17">	<span class="va">R</span>.<span class="at">inc</span></a>
<a class="sourceLine" id="cb14-18" title="18">)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-19" title="19"></a>
<a class="sourceLine" id="cb14-20" title="20"><span class="at">f</span>(<span class="dv">1</span>).<span class="at">then</span>(<span class="va">console</span>.<span class="at">log</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-21" title="21"><span class="co">// 2</span></a>
<a class="sourceLine" id="cb14-22" title="22"><span class="co">// null</span></a></code></pre></div>
<p>我们一共加了三条<code>console.log</code>，结果只打印了两条，从结果看，最后一条<code>R.tap</code>并未执行，看来结果符合预期。</p>
<h3 id="自定义类型hits">自定义类型——Hits</h3>
<p>可以简单把Hits定义为一个复合类型，表示查询结果，可以这么写：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">type</span> <span class="dt">Hits</span> a <span class="fu">=</span> {<span class="ot"> count ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" title="2">              ,<span class="ot"> hits ::</span> [a]</a>
<a class="sourceLine" id="cb15-3" title="3">              }</a></code></pre></div>
<p><code>count</code>表示总数量，<code>hits</code>表示本次查询结果。 对于这样的结果，我们仅仅关心<code>hits</code>，某次查询后得到一组ID，类型为<code>Hits Int</code>，之后通过ID，又得到需要的结果，假设为<code>Hits Item</code>。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="co">/** type Item = { id :: Int } */</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">// Int -&gt; Item</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="kw">const</span> mkItem <span class="op">=</span> <span class="va">R</span>.<span class="at">objOf</span>(<span class="st">&quot;id&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co">// findById :: Int -&gt; Item</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">const</span> findById <span class="op">=</span> mkItem<span class="op">;</span></a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="co">// hits :: Int -&gt; [a] -&gt; Hits a</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="kw">const</span> hits <span class="op">=</span> <span class="va">R</span>.<span class="at">curry</span>((count<span class="op">,</span> hits) <span class="kw">=&gt;</span> (<span class="op">{</span> count<span class="op">,</span> hits<span class="op">}</span> ))<span class="op">;</span></a>
<a class="sourceLine" id="cb16-11" title="11"></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="co">// xhits :: Hits Int</span></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="kw">const</span> xhits <span class="op">=</span> <span class="at">hits</span>(<span class="dv">20</span><span class="op">,</span> <span class="va">R</span>.<span class="at">range</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">11</span>))<span class="op">;</span></a></code></pre></div>
<p>现还我们要将<code>xhits</code>变成<code>Hits Item</code>，简单的方式：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">const</span> nextHits <span class="op">=</span> <span class="va">xhits</span>.<span class="va">hits</span>.<span class="at">map</span>(findById)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="va">xhits</span>.<span class="at">hits</span> <span class="op">=</span> nextHits<span class="op">;</span></a></code></pre></div>
<p>简单有效，这里却有几方面不足：一，实现不纯，更新了<code>xhits</code>的值；二，代码虽短，每次更新都要写这么一段，比较繁琐。或许我们可以抽出一个共用的方法，就像<code>map</code>一样，不用关心内部细节。<code>Hits</code>恰好是一个<em>Functor</em>，我们可以实现与<code>map</code>类似的<code>fmap</code>：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="co">// Lens (Hits a) a</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="kw">const</span> hitsLens <span class="op">=</span> <span class="va">R</span>.<span class="at">lensProp</span>(<span class="st">&quot;hits&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="co">// (a -&gt; b) -&gt; Hits a -&gt; Hits b</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="kw">const</span> fmap <span class="op">=</span> <span class="va">R</span>.<span class="at">curry</span>((f<span class="op">,</span> hits) <span class="kw">=&gt;</span> <span class="va">R</span>.<span class="at">over</span>(</a>
<a class="sourceLine" id="cb18-6" title="6">	hitsLens<span class="op">,</span></a>
<a class="sourceLine" id="cb18-7" title="7">	<span class="va">R</span>.<span class="at">map</span>(f)<span class="op">,</span></a>
<a class="sourceLine" id="cb18-8" title="8">	hits</a>
<a class="sourceLine" id="cb18-9" title="9">))<span class="op">;</span></a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="at">fmap</span>(findById<span class="op">,</span> hits)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="co">// {</span></a>
<a class="sourceLine" id="cb18-13" title="13"><span class="co">//   count: 20,</span></a>
<a class="sourceLine" id="cb18-14" title="14"><span class="co">//   hits: [</span></a>
<a class="sourceLine" id="cb18-15" title="15"><span class="co">//     { item: 1 }, { item: 2 },</span></a>
<a class="sourceLine" id="cb18-16" title="16"><span class="co">//     { item: 3 }, { item: 4 },</span></a>
<a class="sourceLine" id="cb18-17" title="17"><span class="co">//     { item: 5 }, { item: 6 },</span></a>
<a class="sourceLine" id="cb18-18" title="18"><span class="co">//     { item: 7 }, { item: 8 },</span></a>
<a class="sourceLine" id="cb18-19" title="19"><span class="co">//     { item: 9 }, { item: 10 }</span></a>
<a class="sourceLine" id="cb18-20" title="20"><span class="co">//   ]</span></a>
<a class="sourceLine" id="cb18-21" title="21"><span class="co">// }</span></a></code></pre></div>
<p>很简洁，像操作数组一样。实现上，这里运用了透镜，<code>hitsLens</code>聚焦在“hits”上，任何操作仅对该属性有影响。 这里有个问题，<code>findById</code>明显不可能是同步，它要是异步的，<code>fmap</code>岂不是废了？这是当然的，为了解决这一问题，我们使用<code>Traversable</code>：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// (a -&gt; Resolver b) -&gt; Hits a -&gt; Resolver (Hits b)</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">const</span> traverse <span class="op">=</span> <span class="va">R</span>.<span class="at">curry</span>((f<span class="op">,</span> hits) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-3" title="3">	<span class="co">// [a] -&gt; Resolver [b]</span></a>
<a class="sourceLine" id="cb19-4" title="4">	<span class="kw">const</span> g <span class="op">=</span> <span class="va">R</span>.<span class="at">compose</span>(</a>
<a class="sourceLine" id="cb19-5" title="5">		ps <span class="kw">=&gt;</span> <span class="va">Promise</span>.<span class="at">all</span>(ps)<span class="op">,</span></a>
<a class="sourceLine" id="cb19-6" title="6">		<span class="va">R</span>.<span class="at">map</span>(f)</a>
<a class="sourceLine" id="cb19-7" title="7">	)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-8" title="8"></a>
<a class="sourceLine" id="cb19-9" title="9">	<span class="cf">return</span> <span class="at">g</span>(<span class="va">R</span>.<span class="at">view</span>(hitsLens<span class="op">,</span> hits))</a>
<a class="sourceLine" id="cb19-10" title="10">		.<span class="at">then</span>(<span class="va">R</span>.<span class="at">flip</span>(<span class="va">R</span>.<span class="at">set</span>(hitsLens))(hits))</a>
<a class="sourceLine" id="cb19-11" title="11">	<span class="op">;</span></a>
<a class="sourceLine" id="cb19-12" title="12"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-13" title="13"></a>
<a class="sourceLine" id="cb19-14" title="14"><span class="co">// 同时将findById换成异步版本。</span></a>
<a class="sourceLine" id="cb19-15" title="15"><span class="co">// Int -&gt; Resolver Item</span></a>
<a class="sourceLine" id="cb19-16" title="16"><span class="kw">const</span> findById <span class="op">=</span> <span class="va">R</span>.<span class="at">compose</span>(</a>
<a class="sourceLine" id="cb19-17" title="17">	x <span class="kw">=&gt;</span> <span class="va">Promise</span>.<span class="at">resolve</span>(x)<span class="op">,</span></a>
<a class="sourceLine" id="cb19-18" title="18">	mkItem</a>
<a class="sourceLine" id="cb19-19" title="19">)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-20" title="20"></a>
<a class="sourceLine" id="cb19-21" title="21"><span class="kw">const</span> r <span class="op">=</span> <span class="at">traverse</span>(findById<span class="op">,</span> xhits)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-22" title="22"><span class="va">r</span>.<span class="at">then</span>(<span class="va">console</span>.<span class="at">log</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-23" title="23"><span class="co">// {</span></a>
<a class="sourceLine" id="cb19-24" title="24"><span class="co">//   count: 20,</span></a>
<a class="sourceLine" id="cb19-25" title="25"><span class="co">//   hits: [</span></a>
<a class="sourceLine" id="cb19-26" title="26"><span class="co">//     { item: 1 }, { item: 2 },</span></a>
<a class="sourceLine" id="cb19-27" title="27"><span class="co">//     { item: 3 }, { item: 4 },</span></a>
<a class="sourceLine" id="cb19-28" title="28"><span class="co">//     { item: 5 }, { item: 6 },</span></a>
<a class="sourceLine" id="cb19-29" title="29"><span class="co">//     { item: 7 }, { item: 8 },</span></a>
<a class="sourceLine" id="cb19-30" title="30"><span class="co">//     { item: 9 }, { item: 10 }</span></a>
<a class="sourceLine" id="cb19-31" title="31"><span class="co">//   ]</span></a>
<a class="sourceLine" id="cb19-32" title="32"><span class="co">// }</span></a></code></pre></div>
<p>结果一模一样。</p>
<h2 id="更多可能性">更多可能性</h2>
<p>我们实现了<code>composeP</code>、<code>Hits a</code>相关操作函数，不仅封装了细节，同时提供更加简便的操作方式。这两者并不是互不关联，它们可以相互配合使用。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="co">// 找到一堆id</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="at">findIds</span>()</a>
<a class="sourceLine" id="cb20-3" title="3">	<span class="co">// 拼装成需要的数据格式。</span></a>
<a class="sourceLine" id="cb20-4" title="4">	.<span class="at">then</span>(<span class="at">traverse</span>(<span class="at">composeP</span>(</a>
<a class="sourceLine" id="cb20-5" title="5">		findById<span class="op">,</span></a>
<a class="sourceLine" id="cb20-6" title="6">		assocSomething</a>
<a class="sourceLine" id="cb20-7" title="7">	)))</a>
<a class="sourceLine" id="cb20-8" title="8">	.<span class="at">then</span>(...)</a>
<a class="sourceLine" id="cb20-9" title="9"><span class="op">;</span></a></code></pre></div>
<p>我们实现的函数简洁又有很强的组合性。 面对不同需求，我们需要设计不同的数据结构，并不没有统一定式。利用函数式的隔离副作用及组合思想，定能做出正交性强、写法简便的代码。</p>
<h2 id="结语">结语</h2>
<p>函数式带来的更多的是一种设计思想，它不受语言和设计模式限制，就是用C++依然可以写出满足这些条件的代码。</p>
<p>至此，我的JS之旅结束，如非必要，不会特意学习、使用该语言。</p>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>
<entry>
    <title>关于运营后台动态模块权限设计方案的探索</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/Hasekll/2020-07-07-ht.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/Hasekll/2020-07-07-ht.html</id>
    <published>2020-07-07T00:00:00Z</published>
    <updated>2020-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>关于运营后台动态模块权限设计方案的探索</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../css/aono.css">
	<link rel="stylesheet" href="../../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../../index.html">首页</a></li>
				<li class="item"><a href="../../猫.html">分类</a></li>
				<li class="item"><a href="../../标签.html">标签</a></li>
			</ul>

			<a href="../../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				关于运营后台动态模块权限设计方案的探索
				<small class="post date">
					-
					<time datetime="2020-07-07">2020年07月07日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../../%E6%A0%87%E7%AD%BE/Haskell.html">Haskell</a>, <a href="../../%E6%A0%87%E7%AD%BE/%E8%AE%BE%E8%AE%A1.html">设计</a>
		</header>
		<hr>
        <div class="toc">目录：<ul>
<li><a href="#摘要">摘要</a></li>
<li><a href="#背景">背景</a></li>
<li><a href="#整体设计">整体设计</a><ul>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#设计伪代码">设计伪代码</a></li>
<li><a href="#为前端考虑的scope">为前端考虑的scope</a></li>
</ul></li>
<li><a href="#实现网络服务">实现网络服务</a><ul>
<li><a href="#标识请求区分权限">标识请求、区分权限</a></li>
<li><a href="#路由表树">路由表（树）</a></li>
<li><a href="#router">Router</a></li>
<li><a href="#route">route</a></li>
<li><a href="#scope">scope</a></li>
<li><a href="#buildapp">buildApp</a></li>
<li><a href="#runserver">runServer</a></li>
</ul></li>
<li><a href="#实现权限树">实现权限树</a><ul>
<li><a href="#权限树">权限树</a></li>
<li><a href="#从路由到权限">从路由到权限</a></li>
<li><a href="#生成权限树">生成权限树</a></li>
</ul></li>
<li><a href="#结语">结语</a></li>
</ul></div><h2 id="摘要">摘要</h2>
<p>本文探索了一种可用于运营后台的动态权限设计方案，目的是为了避免以往繁琐的权限定义、权限判断。 从<em>请求</em>（<code>Request</code>）基本内容出发，把<code>URI</code>和<em>请求方式</em>（<code>Method</code>）作为权限的最小单元，直接对比得到权限判断结果。</p>
<h2 id="背景">背景</h2>
<p>公司内部都会有个让运营人员使用的后台系统，该系统往往涉及多个模块，每个人员、部门只操作自己那一部分。随着事务变理、增加、删减，往往会导致权限分配混乱不明、新旧代码难分难解。 手工定义每个模块、功能权限，一来难免会有遗漏，二来不容易统一管理。我们不妨改变一下原有思路，“权限”的出现是为了什么？“权限”本质上就是为了限制用户访问某个资源，那我们能不能直接从该资源入手？能否取消以前权限定义，以更直接方式处理？</p>
<p>假设有这么些个接口：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># 获取物品</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ex">GET</span> /item</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"># 更新物品</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ex">PUT</span> /item</a></code></pre></div>
<p>我们需要限定部分人访问，于是我们写下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> GET_ITEM_ROLE <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">const</span> PUT_TIME_ROLE <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> user <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-5" title="5">	<span class="cf">if</span> (<span class="va">user</span>.<span class="at">role</span> <span class="op">===</span> GET_ITEM_ROLE) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">		<span class="co">// 继续操作。</span></a>
<a class="sourceLine" id="cb2-7" title="7">	<span class="op">}</span></a>
<a class="sourceLine" id="cb2-8" title="8">	<span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-9" title="9">		<span class="co">// 无权访问。</span></a>
<a class="sourceLine" id="cb2-10" title="10">		<span class="at">status</span>(<span class="dv">403</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-11" title="11">	<span class="op">}</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">// PUT 相同逻辑。</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>写起来繁琐，我们可能会考虑利用中间件实现权限限制：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(GET_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(PUT_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>已经改观很多，但依然要指定<code>ROLE</code>，每次新增路由，都要再定义新<code>ROLE</code>，这样的样板代码已经无法消除掉了。 我们回过头来看<code>GET_ITEM_ROLE</code>和<code>PUT_ITEM_ROLE</code>，我们知道它们作用是为表明某个资源的访问权限，可以是任意值，假使让它们跟访问uri是同一个值会如何？我们改写上面的例子：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">const</span> GET_ITEM_ROLE <span class="op">=</span> <span class="st">&quot;/item&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">const</span> PUT_TIME_ROLE <span class="op">=</span> <span class="st">&quot;/item&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(GET_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(PUT_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>这样<code>GET_ITEM_ROLE</code>和<code>PUT_ITEM_ROLE</code>就没分别了，仔细想想，除了uri不同，还有区别就是<em>请求方式</em>（request method）不一样，一个是<code>GET</code>，另一个是<code>PUT</code>，把它们补充上去：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> GET_ITEM_ROLE <span class="op">=</span> [<span class="st">&quot;GET&quot;</span><span class="op">,</span> <span class="st">&quot;/item&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">const</span> PUT_TIME_ROLE <span class="op">=</span> [<span class="st">&quot;PUT&quot;</span><span class="op">,</span> <span class="st">&quot;/item&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(GET_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(PUT_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>再仔细观察，<code>method</code>和<code>uri</code>不就是能从<code>request</code>中取到的吗？何必再重新定义一遍？</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="va">app</span>.<span class="at">checkGet</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="va">app</span>.<span class="at">checkPut</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>换成这样的写法，将路由的定义和权限判断写在一起，不仅不会遗漏，而且不需要额外定义新变量——只管定义路由，权限的事自动处理掉。</p>
<p>这种设计另一个好处就是可以生成用户允许操作的菜单，由于路由在写代写完那一刻就已确定，同时已经用户拥有的权限（可能存在数据库），我们只需要构造出满足用户权限的路由表，输出到前端，渲染出来。同样减少前端工作量。</p>
<p>例如全部路由：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">|</span><span class="ex">-</span> /user</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">|</span>   <span class="kw">|</span><span class="ex">-</span> /view</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">|</span>	<span class="kw">|</span><span class="ex">-</span> /create</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">|</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">|</span><span class="ex">-</span> /item</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">|</span><span class="ex">-</span> /create</a></code></pre></div>
<p>某用户只有<code>/item</code>权限，最后他只能得到部分路由树：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">|</span><span class="ex">-</span> /item</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">|</span><span class="ex">-</span> /create</a></code></pre></div>
<p>这一切都是动态的。在路由定义好的那一刻就已确定！</p>
<h2 id="整体设计">整体设计</h2>
<div class="注意！">
<p>虽然重点在权限设计，但本文还是从最基础的网服服务开始搭建。 世面上网络服务框架基本不会收集所有路由信息，并能在路由内部直接获取，所以不得不重新建一个网络服务。 同时不涉及数据库存储、前端（GUI）等方面。</p>
</div>
<h3 id="haskell">Haskell</h3>
<p>演示语言选用Haskell，除了偏好外，它还有几个优点：</p>
<ul>
<li>有很多抽象概念，方便写DSL。</li>
<li>生态健康，方便写DSL。</li>
<li>方便写DSL。</li>
</ul>
<p>我们直接从<code>wai</code>（低层次的网络服务库）开始，本文仅仅是为探讨权限设计问题，焦点在<strong>权限</strong>上，不在框架上，所以很多地方——<code>params</code>解析等——就省略了。</p>
<h3 id="设计伪代码">设计伪代码</h3>
<p>选好了语言，接下来就是要设计目标，我们打算这样写路由和启动服务：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-2" title="2">    get <span class="st">&quot;/home&quot;</span> <span class="fu">$</span> text <span class="st">&quot;home&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3">    get <span class="st">&quot;/view&quot;</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-4" title="4">        tree <span class="ot">&lt;-</span> askPathTree</a>
<a class="sourceLine" id="cb9-5" title="5">        <span class="kw">let</span> xs <span class="fu">=</span> catMaybes <span class="fu">$</span> <span class="fu">map</span> (walkInPathTree tree) permission</a>
<a class="sourceLine" id="cb9-6" title="6">            tree' <span class="fu">=</span> <span class="fu">foldl</span> mergePathNode <span class="fu">mempty</span> xs</a>
<a class="sourceLine" id="cb9-7" title="7">        <span class="fu">pure</span> <span class="fu">$</span> string tree'</a>
<a class="sourceLine" id="cb9-8" title="8">    scope <span class="st">&quot;/user&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-9" title="9">        post <span class="st">&quot;/create&quot;</span> <span class="fu">$</span> text <span class="st">&quot;create user&quot;</span></a>
<a class="sourceLine" id="cb9-10" title="10">        get <span class="st">&quot;/user&quot;</span> <span class="fu">$</span> text <span class="st">&quot;get user&quot;</span></a>
<a class="sourceLine" id="cb9-11" title="11">        scope <span class="st">&quot;/vip&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-12" title="12">            get <span class="st">&quot;/user&quot;</span> <span class="fu">$</span> text <span class="st">&quot;vip user&quot;</span></a>
<a class="sourceLine" id="cb9-13" title="13"></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-15" title="15">main <span class="fu">=</span> runServer router</a></code></pre></div>
<p>排除<code>get &quot;/view&quot; ...</code>那块复杂的代码，其它部分都是定义了路由及相关操作。也就是我们先收集所有路由信息，然后对每一个请求做分发。</p>
<h3 id="为前端考虑的scope">为前端考虑的scope</h3>
<p>上述代码出现了三种定义路由的方式：<code>get</code>、<code>post</code>、<code>scope</code>。前两者容易理解，对于整个后端而言，也足够使用，但为何需要<code>scope</code>？ <code>scope</code>源自<a href="https://actix.rs/actix-web/actix_web/web/fn.scope.html">actix-web</a>，目的表示一个树结点，表示下面还有子结点。 最终整个路由展示出来的是一颗普通树，这颗树（根据用户权限生成）就是最终用户可操作菜单，前端只需要根据该结构渲染出菜单即可。</p>
<h2 id="实现网络服务">实现网络服务</h2>
<p>考虑到无关代码太多，不列出来又让人费解，所以最好边照<a href="https://github.com/kalxd/api-layout/blob/master/src/Lib.hs">源码</a>边往下看。</p>
<h3 id="标识请求区分权限">标识请求、区分权限</h3>
<p>上面讲到，仅有一个<code>uri</code>是无法区分哪条请求，也无法区分对应权限，还需要<code>method</code>。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">newtype</span> <span class="dt">XPath</span> <span class="fu">=</span> <span class="dt">XPath</span> {<span class="ot"> readPath ::</span> (<span class="dt">StdMethod</span>, <span class="dt">Path</span>) }</a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>一个<code>XPath</code>就是验证的最小单元。</p>
<h3 id="路由表树">路由表（树）</h3>
<p>回到上面伪代码那段代码，先不管如何收集这些路由，我们考虑一下保存到哪种数据结构里。很明显，为了方便前端渲染菜单，这个菜单一般是树型结构，那么结果自然要保存到树。以此为思路，我们将伪代码路由输出：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">|</span><span class="ex">-</span> (GET, /home)</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">|</span><span class="ex">-</span> (GET, /view)</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">|</span><span class="ex">-</span> /user</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="kw">|</span><span class="ex">-</span> (POST, /create)</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="kw">|</span><span class="ex">-</span> (GET, /user)</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="kw">|</span><span class="ex">-</span> /vip</a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="kw">|</span><span class="ex">-</span> (GET, /user)</a></code></pre></div>
<p>很明显看到结点有两种，一种就是<em>scope</em>，它处在中间，另一种就是叶子结点。那么我们先定义出结点类型：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">RouterNode</span> <span class="fu">=</span> <span class="dt">RouterLeaf</span> <span class="dt">XPath</span> <span class="dt">Handler</span></a>
<a class="sourceLine" id="cb12-2" title="2">                <span class="fu">|</span> <span class="dt">RouterScope</span> <span class="dt">Path</span> [<span class="dt">RouterNode</span>]</a></code></pre></div>
<p>那么树类型也就呼之欲出：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">data</span> <span class="dt">RouterTree</span> <span class="fu">=</span> <span class="dt">RouterTree</span> [<span class="dt">RouterNode</span>]</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">RouterTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" title="5">    (<span class="dt">RouterTree</span> xs) <span class="fu">&lt;&gt;</span> (<span class="dt">RouterTree</span> ys) <span class="fu">=</span> <span class="dt">RouterTree</span> <span class="fu">$</span> xs <span class="fu">&lt;&gt;</span> ys</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">RouterTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-8" title="8">    <span class="fu">mempty</span> <span class="fu">=</span> <span class="dt">RouterTree</span> <span class="fu">mempty</span></a></code></pre></div>
<p>这里实现幺半群实例，是为了后面路由的叠加作准备。</p>
<h3 id="router">Router</h3>
<p>我们再看这样的代码：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-2" title="2">    get <span class="st">&quot;/abc&quot;</span> <span class="fu">$</span> f</a>
<a class="sourceLine" id="cb14-3" title="3">	scope <span class="st">&quot;/scope&quot;</span></a>
<a class="sourceLine" id="cb14-4" title="4">	get <span class="st">&quot;/xyz&quot;</span></a></code></pre></div>
<p>省略掉<code>scope</code>后半部分，我们很容易得到它们类型接近——<code>T a</code>，只有<code>a</code>不确定。每次写<code>get</code>或<code>scope</code>都是往路由表里追加新路由，这种操作很容易想到<em>Writer</em>。</p>
<p>Router类型可以这么定义：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">type</span> <span class="dt">Router</span> <span class="fu">=</span> <span class="dt">WriterT</span> <span class="dt">RouterTree</span> <span class="dt">IO</span></a></code></pre></div>
<h3 id="route">route</h3>
<p><code>get</code>、<code>post</code>仅仅<code>method</code>不相同，我们可以抽出更通用方法：<code>route</code>。</p>
<p>由上可知，<code>route</code>最后也是要返回<code>Router a</code>：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">route ::</span> <span class="dt">StdMethod</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb16-2" title="2">route method path handler <span class="fu">=</span> tell <span class="fu">$</span> <span class="dt">RouterTree</span> [tree]</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="kw">where</span> tree <span class="fu">=</span> <span class="dt">RouterLeaf</span> xpath handler</a>
<a class="sourceLine" id="cb16-4" title="4">          xpath <span class="fu">=</span> <span class="dt">XPath</span> (method, path)</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co">-- 有了`route`，`get`、`post`都能容易实现。</span></a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="ot">get ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb16-9" title="9">get <span class="fu">=</span> route <span class="dt">GET</span></a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="ot">post ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb16-12" title="12">post <span class="fu">=</span> route <span class="dt">POST</span></a></code></pre></div>
<h3 id="scope">scope</h3>
<p>我们对比这两段代码：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="co">-- # 1</span></a>
<a class="sourceLine" id="cb17-2" title="2">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-3" title="3">    get <span class="st">&quot;/a&quot;</span></a>
<a class="sourceLine" id="cb17-4" title="4">    get <span class="st">&quot;/b&quot;</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co">-- # 2</span></a>
<a class="sourceLine" id="cb17-7" title="7">scope <span class="st">&quot;/x&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-8" title="8">    get <span class="st">&quot;/a&quot;</span></a>
<a class="sourceLine" id="cb17-9" title="9">    get <span class="st">&quot;/b&quot;</span></a></code></pre></div>
<p>十分相像，一个是根结点，一个是中间结点，处理差不是很多，唯一不同的是要追加到对应的地方：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">scope ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> a <span class="ot">-&gt;</span> <span class="dt">Router</span> a</a>
<a class="sourceLine" id="cb18-2" title="2">scope path <span class="fu">=</span> mapWriterT (<span class="fu">fmap</span> f)</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">where</span> f <span class="fu">=</span> <span class="fu">fmap</span> g</a>
<a class="sourceLine" id="cb18-4" title="4">          g (<span class="dt">RouterTree</span> xs) <span class="fu">=</span> <span class="dt">RouterTree</span> <span class="fu">$</span> [<span class="dt">RouterScope</span> path xs]</a></code></pre></div>
<h3 id="buildapp">buildApp</h3>
<p>我们已经收集到全部路由了，接下来就是做转发。<code>Network.Wai.Wrap.run</code>需要接受<code>Application</code>，在这里我们就要构造出来：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">buildApp ::</span> <span class="dt">RouterTree</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb19-2" title="2">buildApp tree req send <span class="fu">=</span> <span class="kw">case</span> handler <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-3" title="3">                            <span class="dt">Just</span> handler' <span class="ot">-&gt;</span> handler' req <span class="fu">&gt;&gt;=</span> send</a>
<a class="sourceLine" id="cb19-4" title="4">                            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> send <span class="fu">$</span> textResponse <span class="st">&quot;not found&quot;</span></a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="kw">where</span> path <span class="fu">=</span> rawPathInfo req</a>
<a class="sourceLine" id="cb19-6" title="6">          method <span class="fu">=</span> requestMethod req</a>
<a class="sourceLine" id="cb19-7" title="7">          handler <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-8" title="8">              method' <span class="ot">&lt;-</span> toStdMethod method</a>
<a class="sourceLine" id="cb19-9" title="9">              matchHandler method' path tree</a></code></pre></div>
<h3 id="runserver">runServer</h3>
<p>作为演示，我们默认3000端口。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">runServer ::</span> <span class="dt">Router</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-2" title="2">runServer router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-3" title="3">    tree <span class="ot">&lt;-</span> execWriterT router</a>
<a class="sourceLine" id="cb20-4" title="4">    run <span class="dv">3000</span> <span class="fu">$</span> buildApp tree</a></code></pre></div>
<p>至此我们已经完成了所有工作，这已经是一个能做分发的网络服务框架。我们写段测试代码看看效果：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">router ::</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb21-2" title="2">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-3" title="3">    get <span class="st">&quot;/a&quot;</span> <span class="fu">$</span> text <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb21-4" title="4">	get <span class="st">&quot;/b&quot;</span> <span class="fu">$</span> text <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb21-5" title="5">	scope <span class="st">&quot;/f&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-6" title="6">	    get <span class="st">&quot;c&quot;</span> <span class="fu">$</span> text <span class="st">&quot;c&quot;</span></a>
<a class="sourceLine" id="cb21-7" title="7">		post <span class="st">&quot;d&quot;</span> <span class="fu">$</span> text <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-10" title="10">main <span class="fu">=</span> runServer router</a></code></pre></div>
<p>访问<em>localhost:3000/f/c</em>可以看到输出“c”。</p>
<h2 id="实现权限树">实现权限树</h2>
<p>目前为止，我们只实现最基本的网络服务，权限相关尚未涉及。 在设计之前，我们不妨想一想如何记录下用户的权限呢？以上面代码为例，假设用户可以访问<code>(GET, &quot;/a&quot;)</code>和<code>(POST, &quot;/f/d&quot;)</code>，用哪种结构最适宜？ 从树角度来看，它们没有共同根结点，虽然可以构造出虚拟根结点，但使用起来跟数组差不多，而且数组是多大存储服务支持的；从演示角度来讲，数组更方便些。</p>
<h3 id="权限树">权限树</h3>
<p>既然有了<a href="#路由表树">RouterTree</a>为什么还要再设计同样功能的树呢？ <code>RouterTree</code>除了记录路由之外，它还要保存<code>Handler</code>，我们说过前端菜单是由它生成的，<code>Handler</code>显然多余；它们除了记录路由以外，其他作用并不相同，处于不同范畴。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">data</span> <span class="dt">PathNode</span> <span class="fu">=</span> <span class="dt">PathScope</span> <span class="dt">Path</span> [<span class="dt">PathNode</span>]</a>
<a class="sourceLine" id="cb22-2" title="2">              <span class="fu">|</span> <span class="dt">PathLeaf</span> <span class="dt">XPath</span></a>
<a class="sourceLine" id="cb22-3" title="3">              <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="kw">data</span> <span class="dt">PathTree</span> <span class="fu">=</span> <span class="dt">PathTree</span> [<span class="dt">PathNode</span>]</a>
<a class="sourceLine" id="cb22-6" title="6">              <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb22-7" title="7"></a>
<a class="sourceLine" id="cb22-8" title="8"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">PathTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-9" title="9">    (<span class="dt">PathTree</span> xs) <span class="fu">&lt;&gt;</span> (<span class="dt">PathTree</span> ys) <span class="fu">=</span> <span class="dt">PathTree</span> <span class="fu">$</span> xs <span class="fu">&lt;&gt;</span> ys</a>
<a class="sourceLine" id="cb22-10" title="10"></a>
<a class="sourceLine" id="cb22-11" title="11"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">PathTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-12" title="12">    <span class="fu">mempty</span> <span class="fu">=</span> <span class="dt">PathTree</span> <span class="fu">mempty</span></a></code></pre></div>
<h3 id="从路由到权限">从路由到权限</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">router ::</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb23-2" title="2">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" title="3">    get <span class="st">&quot;/view&quot;</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-4" title="4">        tree <span class="ot">&lt;-</span> askPathTree</a>
<a class="sourceLine" id="cb23-5" title="5">        <span class="kw">let</span> xs <span class="fu">=</span> catMaybes <span class="fu">$</span> <span class="fu">map</span> (walkInPathTree tree) permission</a>
<a class="sourceLine" id="cb23-6" title="6">            tree' <span class="fu">=</span> <span class="fu">foldl</span> mergePathNode <span class="fu">mempty</span> xs</a>
<a class="sourceLine" id="cb23-7" title="7">        <span class="fu">pure</span> <span class="fu">$</span> string tree'</a></code></pre></div>
<p>这是伪代码中的一段，之前特意把这一段忽略，下面讲讲它的特殊之处。 这一整段代码最关键的是<code>askPathTree</code>，调用它会得到整颗权限树，特别就特别它处在<code>Handler</code>之中，单纯的<code>WriterT</code>无法预先得知所有信息，只有整段代码运行完才知晓。 这段代码恰巧处在上面，在静态语言中如何获取就成了关键。</p>
<p>根据直觉，路由收集在编译期可以直接得到，那么将结果保存到一个变量里，运行时再取出来不就解决了？于是我们使用IORef，创建一个全局变量。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">unsafePathTree ::</span> <span class="dt">IORef</span> <span class="dt">PathTree</span></a>
<a class="sourceLine" id="cb24-2" title="2">unsafePathTree <span class="fu">=</span> unsafePerformIO <span class="fu">$</span> newIORef <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="ot">askPathTree ::</span> <span class="dt">IO</span> <span class="dt">PathTree</span></a>
<a class="sourceLine" id="cb24-5" title="5">askPathTree <span class="fu">=</span> readIORef unsafePathTree</a></code></pre></div>
<p>全局变量不纯，所以是个IO操作。</p>
<p>再改造一下<code>runServer</code>，将结果保存下来：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb25-1" title="1">runServer :: Router a -&gt; IO ()</a>
<a class="sourceLine" id="cb25-2" title="2">runServer router = do</a>
<a class="sourceLine" id="cb25-3" title="3">    tree &lt;- execWriterT router</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="va">+   writeIORef unsafePathTree $ toPathTree tree</span></a>
<a class="sourceLine" id="cb25-5" title="5">    run 3000 $ buildApp tree</a></code></pre></div>
<h3 id="生成权限树">生成权限树</h3>
<p>差不多到最后几步了，回到开头，我们假设用户拥有如下权限：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">permission ::</span> [<span class="dt">XPath</span>]</a>
<a class="sourceLine" id="cb26-2" title="2">permission <span class="fu">=</span> [ <span class="dt">XPath</span> (<span class="dt">GET</span>, <span class="st">&quot;/home&quot;</span>) <span class="co">-- # 1</span></a>
<a class="sourceLine" id="cb26-3" title="3">             , <span class="dt">XPath</span> (<span class="dt">POST</span>, <span class="st">&quot;/home&quot;</span>) <span class="co">-- # 2</span></a>
<a class="sourceLine" id="cb26-4" title="4">             , <span class="dt">XPath</span> (<span class="dt">GET</span>, <span class="st">&quot;/user/vip/user&quot;</span>) <span class="co">-- # 3</span></a>
<a class="sourceLine" id="cb26-5" title="5">             ]</a></code></pre></div>
<p>很明显<em># 2</em>不存在，需要过滤。我们把合法权限输出：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">|</span><span class="ex">-</span> (GET, /home)      <span class="kw">|</span><span class="ex">-</span> /user</a>
<a class="sourceLine" id="cb27-2" title="2">                         <span class="kw">|</span><span class="ex">-</span> /vip</a>
<a class="sourceLine" id="cb27-3" title="3">                             <span class="kw">|</span><span class="ex">-</span> (GET, /user)</a></code></pre></div>
<p>将它们合在一起就是最后用户所能操作的所有权限了：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="fu">|-</span> (<span class="dt">GET</span>, <span class="fu">/</span>home)</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="fu">|-</span> <span class="fu">/</span>user</a>
<a class="sourceLine" id="cb28-3" title="3">    <span class="fu">|-</span> <span class="fu">/</span>vip</a>
<a class="sourceLine" id="cb28-4" title="4">        <span class="fu">|-</span> (<span class="dt">GET</span>, <span class="fu">/</span>user)</a></code></pre></div>
<p>同样的思路，我们依次取出每条权限树，最后作个合并：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="co">-- | 生成单条权限树。</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="ot">walkInPathTree ::</span> <span class="dt">PathTree</span> <span class="ot">-&gt;</span> <span class="dt">XPath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">PathNode</span></a>
<a class="sourceLine" id="cb29-3" title="3">walkInPathTree (<span class="dt">PathTree</span> xs) xpath<span class="fu">@</span>(<span class="dt">XPath</span> (method, path)) <span class="fu">=</span> asum <span class="fu">$</span> <span class="fu">map</span> f xs</a>
<a class="sourceLine" id="cb29-4" title="4">    <span class="kw">where</span> f node<span class="fu">@</span>(<span class="dt">PathLeaf</span> xpath') <span class="fu">=</span> <span class="kw">if</span> xpath <span class="fu">==</span> xpath'</a>
<a class="sourceLine" id="cb29-5" title="5">                                     <span class="kw">then</span> <span class="dt">Just</span> node</a>
<a class="sourceLine" id="cb29-6" title="6">                                     <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb29-7" title="7">          f (<span class="dt">PathScope</span> path' ys) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-8" title="8">              subpath <span class="ot">&lt;-</span> BS.stripPrefix path' path</a>
<a class="sourceLine" id="cb29-9" title="9">              child <span class="ot">&lt;-</span> walkInPathTree (<span class="dt">PathTree</span> ys) (<span class="dt">XPath</span> (method, subpath))</a>
<a class="sourceLine" id="cb29-10" title="10">              <span class="fu">pure</span> <span class="fu">$</span> <span class="dt">PathScope</span> path' <span class="fu">$</span> [child]</a>
<a class="sourceLine" id="cb29-11" title="11"></a>
<a class="sourceLine" id="cb29-12" title="12"><span class="co">-- | 合并</span></a>
<a class="sourceLine" id="cb29-13" title="13"><span class="ot">mergePathNode ::</span> <span class="dt">PathTree</span> <span class="ot">-&gt;</span> <span class="dt">PathNode</span> <span class="ot">-&gt;</span> <span class="dt">PathTree</span></a>
<a class="sourceLine" id="cb29-14" title="14">mergePathNode tree<span class="fu">@</span>(<span class="dt">PathTree</span> xs) node<span class="fu">@</span>(<span class="dt">PathLeaf</span> _)</a>
<a class="sourceLine" id="cb29-15" title="15">    <span class="fu">|</span> <span class="fu">elem</span> node xs <span class="fu">=</span> tree</a>
<a class="sourceLine" id="cb29-16" title="16">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> tree <span class="fu">&lt;&gt;</span> <span class="dt">PathTree</span> [node]</a>
<a class="sourceLine" id="cb29-17" title="17">mergePathNode tree<span class="fu">@</span>(<span class="dt">PathTree</span> xs) node<span class="fu">@</span>(<span class="dt">PathScope</span> _ _) <span class="fu">=</span> <span class="kw">case</span> find (<span class="fu">==</span> node) xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-18" title="18">                                                            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> tree <span class="fu">&lt;&gt;</span> <span class="dt">PathTree</span> [node]</a>
<a class="sourceLine" id="cb29-19" title="19">                                                            <span class="dt">Just</span> node' <span class="ot">-&gt;</span> tree <span class="fu">&lt;&gt;</span> <span class="dt">PathTree</span> [f node' node]</a>
<a class="sourceLine" id="cb29-20" title="20">    <span class="kw">where</span> f scope<span class="fu">@</span>(<span class="dt">PathScope</span> method xs) (<span class="dt">PathScope</span> _ [x]) <span class="fu">=</span> <span class="dt">PathScope</span> method <span class="fu">$</span> pathTreeChildren <span class="fu">$</span> mergePathNode (<span class="dt">PathTree</span> xs) x</a></code></pre></div>
<div class="提示">
<p>总体实现粗糙，不停地打包、解包。</p>
<p>对比<code>RouterTree</code>和<code>PathTree</code>，它们仅仅是内部存储数据不同，我们可以单独抽出<code>Tree a b</code>，那么：</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="kw">data</span> <span class="dt">Tree</span> a b <span class="fu">=</span> <span class="dt">TreeLeaf</span> b</a>
<a class="sourceLine" id="cb30-3" title="3">              <span class="fu">|</span> <span class="dt">TreeNode</span> a [<span class="dt">Tree</span> a b]</a>
<a class="sourceLine" id="cb30-4" title="4"></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="kw">type</span> <span class="dt">RouterTree</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Path</span> (<span class="dt">XPath</span>, <span class="dt">Handler</span>)</a>
<a class="sourceLine" id="cb30-6" title="6"><span class="kw">type</span> <span class="dt">PathTree</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Path</span> <span class="dt">XPath</span></a></code></pre></div>
<p>不过这些都是后话，不在此处讨论的重点。</p>
</div>
<p>启动服务，查看<em>localhost:3000/view</em>就能看到该用户的权限树。</p>
<h2 id="结语">结语</h2>
<p>这套系统将以往权限定义与路由定义结合起来，在不影响原有业务逻辑前提下，依旧采用普通写法就能自动处理逻辑，从杂乱权限变量中解脱出来。生成的权限树，又能为前端提供渲染成菜单数据，也减少前端的工作量。</p>
<p>设计核心在于：当程序员编完路由后，整个程序能接受、不能接受哪些请求是十分确定的；权限之于用户，相当于是否授权访问某个路由。由此我们将路由信息与权限绑定，当新定义一条路由时，也相当于新定义一条权限。 代码组织上有层次结构，那么路由设计上也可以有层次，后台的侧边栏就是一个例子，一级菜单下有二级菜单，二级下有三级……我们再利用这种结构，将用户可访问的所有路由输出前端，由前端自动生成侧边栏菜单。</p>
<p>这些举措，后端新定义一个新路由，自动添加新权限，并自动更新前端侧边栏菜单。</p>
<p>这一套代码仅仅做了收集、过滤权限，用户权限分配、权限验证（过滤也能算一小部分）都未涉及； 前端菜单往往需要更多信息，单纯<code>PathTree</code>肯定无法满足。 如果做起来，差不多就要再造一个框架了。</p>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>
<entry>
    <title>中文排版处理简易说明</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/2020-04-28-guide.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/2020-04-28-guide.html</id>
    <published>2020-04-28T00:00:00Z</published>
    <updated>2020-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>中文排版处理简易说明</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../css/aono.css">
	<link rel="stylesheet" href="../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../index.html">首页</a></li>
				<li class="item"><a href="../猫.html">分类</a></li>
				<li class="item"><a href="../标签.html">标签</a></li>
			</ul>

			<a href="../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				中文排版处理简易说明
				<small class="post date">
					-
					<time datetime="2020-04-28">2020年04月28日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../%E6%A0%87%E7%AD%BE/%E6%8E%92%E7%89%88.html">排版</a>, <a href="../%E6%A0%87%E7%AD%BE/%E6%B1%89%E5%AD%97.html">汉字</a>
		</header>
		<hr>
        <div class="toc">目录：<ul>
<li><a href="#中文书写">中文书写</a><ul>
<li><a href="#中文标点">中文标点</a></li>
<li><a href="#斜体粗体">斜体？粗体？</a></li>
</ul></li>
<li><a href="#其他扩展">其他扩展</a><ul>
<li><a href="#生成目录">生成目录</a></li>
<li><a href="#数学公式">数学公式</a></li>
<li><a href="#各式文本框">各式文本框</a></li>
<li><a href="#多列显示">多列显示</a></li>
</ul></li>
<li><a href="#限制">限制</a><ul>
<li><a href="#兼容性限制">兼容性限制</a></li>
<li><a href="#标题等级限制">标题等级限制</a></li>
<li><a href="#文件名与标题">文件名与标题</a></li>
</ul></li>
</ul></div><p>本篇用于说明该博客程序对中文排版做了哪些处理，以及其他零散扩展。</p>
<h2 id="中文书写">中文书写</h2>
<p>中文书写，如这篇文字所示，每段开头空两格，段落与段落之间不加空行。在实际写作过程中，开头两空不必手动添加，CSS已经作了处理。 另外汉字很少有“斜体”“粗体”，这些样式可以看成西欧排版独有，所以我以“楷体”表示“斜体”，“黑体”表示“粗体”。</p>
<h3 id="中文标点">中文标点</h3>
<p>中文标点有许多符号，具体规范查看<a href="http://www.wenming.cn/xwcb_pd/xytt/201707/t20170723_4352427.shtml">《标点符号用法》</a>。 键盘上能打出的标点都支持；部分需要css支持，终端上与常字无异；css不支持的标点就放弃了。</p>
<h3 id="斜体粗体">斜体？粗体？</h3>
<p>“斜体”“粗体”算是西欧标准，中文字体少有这样的样式，我们已经有<em>专名号</em>和<strong>着重号</strong>，基本上不沿用“斜体”“粗体”样式，所以这两部分做了各自处理：</p>
<ol>
<li>“斜体”以“专名号”代替，使用“楷体”字体，表示专有名词。</li>
<li>“粗体”使用“黑体”字体，文字下面加黑点，表示强调。</li>
</ol>
<h2 id="其他扩展">其他扩展</h2>
<h3 id="生成目录">生成目录</h3>
<p>在原信息中添加<code>toc: &lt;n&gt;</code>，<code>&lt;n&gt;</code>表示目录等级，例如本篇的n=3。只有填写上该项才会生成目录，这一点需要注意。</p>
<h3 id="数学公式">数学公式</h3>
<h4 id="内联公式">内联公式</h4>
<p>公式写在<em>$</em>之间，紧贴<em>$</em>，不能有空格。格式如下：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb1-1" title="1">$y = x + 1$</a></code></pre></div>
<div class="提示">
<p><span class="math inline"><em>y</em></span>在区间<span class="math inline">[1,  + ∞)</span>单调递增。</p>
</div>
<h4 id="单独公式">单独公式</h4>
<p>公式写在<em>$$</em>之间，一条公式一块<em>$$</em>。格式如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb2-1" title="1">$$\forall x \in X, \quad \exists y \leq \epsilon$$</a></code></pre></div>
<p>一个示例：</p>
<div class="结论！">
<p>设<span class="math inline"><em>α</em></span>为任意角，终边相同的角的同一三角形函数的值相等。<span class="math inline"><em>k</em></span>是整数。</p>
<p><br /><span class="math display">sin (2<em>k</em><em>π</em> + <em>α</em>) = sin <em>α</em></span><br /></p>
</div>
<h3 id="各式文本框">各式文本框</h3>
<p><em>pandoc markdown</em>可以创建自定义div，利用这个特性，作出了以下几种文本框样式。<strong>因为只是一块div，所以在终端看起来没有任何区别</strong>！</p>
<h4 id="使用方式">使用方式</h4>
<p>格式如下：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb3-1" title="1">::: [样式名]</a>
<a class="sourceLine" id="cb3-2" title="2">内容</a>
<a class="sourceLine" id="cb3-3" title="3">:::</a></code></pre></div>
<p><em>样式名</em>有两种，一种仅带名称，另一种名称后带中文感叹号（！）。</p>
<div class="两栏">
<div class="列">
<div class="注意">
<p>一般的“注意”。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb4-1" title="1">::: 注意</a>
<a class="sourceLine" id="cb4-2" title="2">一般的“注意”。</a>
<a class="sourceLine" id="cb4-3" title="3">:::</a></code></pre></div>
</div>
</div>
<div class="列">
<div class="注意！">
<p>带标题的注意。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb5-1" title="1">::: 注意！</a>
<a class="sourceLine" id="cb5-2" title="2">带标题的注意。</a>
<a class="sourceLine" id="cb5-3" title="3">:::</a></code></pre></div>
</div>
</div>
</div>
<h4 id="全部文本框">全部文本框</h4>
<div class="两栏">
<div class="列">
<div class="提示">
<p>提示</p>
</div>
</div>
<div class="列">
<div class="提示！">
<p>提示！</p>
</div>
</div>
</div>
<div class="两栏">
<div class="列">
<div class="注意">
<p>注意</p>
</div>
</div>
<div class="列">
<div class="注意！">
<p>注意！</p>
</div>
</div>
</div>
<hr />
<div class="两栏">
<div class="列">
<div class="定义">
<p>定义</p>
</div>
</div>
<div class="列">
<div class="定义！">
<p>定义！</p>
</div>
</div>
</div>
<div class="两栏">
<div class="列">
<div class="定理">
<p>定理</p>
</div>
</div>
<div class="列">
<div class="定理！">
<p>定理！</p>
</div>
</div>
</div>
<div class="两栏">
<div class="列">
<div class="命题">
<p>命题</p>
</div>
</div>
<div class="列">
<div class="命题！">
<p>命题！</p>
</div>
</div>
</div>
<div class="两栏">
<div class="列">
<div class="结论">
<p>结论</p>
</div>
</div>
<div class="列">
<div class="结论！">
<p>结论！</p>
</div>
</div>
</div>
<h3 id="多列显示">多列显示</h3>
<p><strong>终端依然不支持该特性</strong>！</p>
<p>该程序只支持到三列，本应可以做到支持无限列数，出于平日需求及稳定性而言，固定列数更方便实现、更可靠。</p>
<h4 id="两列">两列</h4>
<p>语法如下：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb6-1" title="1">::: 两栏 :::</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3">::: 列</a>
<a class="sourceLine" id="cb6-4" title="4">这是左一列。</a>
<a class="sourceLine" id="cb6-5" title="5">:::</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7">::: 列</a>
<a class="sourceLine" id="cb6-8" title="8">这是右一列。</a>
<a class="sourceLine" id="cb6-9" title="9">:::</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">:::::::</a></code></pre></div>
<p>示例：</p>
<div class="提示">
<p>唐诗宋词的区别：</p>
<div class="两栏">
<div class="列">
<p>诗庄词媚。唐诗恢弘大气，就算是以情诗为代表的李商隐也有很多气势磅礴的诗，如：</p>
<blockquote>
<p>玉玺不缘归日角，锦帆应是到天涯。</p>
<p>永忆江湖归白发，欲回天地入扁舟。</p>
<p>阵图东聚燕江石，边坼西悬雪岭松。</p>
<p>雪岭未归天外使，松州犹驻殿前军。</p>
</blockquote>
</div>
<div class="列">
<p>宋词清新婉约，主流是“小屏谁与画鸳鸯”这种基调。 就算是豪放派的苏辛，词也是以婉约为主，文学界给人的感觉是长者的欧阳修写的词也让人觉得这个糟老头子骚得很。</p>
</div>
</div>
<p>诗词不能只看句子，也要看整体。 就像打游戏，同样的操作，不同的队友就会有不同的效果。 晏殊的那首诗以说教结尾，“游梁赋客多风味，莫惜青钱万选才”，说教结尾一般效果都不好(李颀的莫见长安行乐处，空令岁月易蹉跎可以)。 词则是中规中矩的“小园香径独徘徊”，含而不露，有余味。</p>
</div>
<h4 id="三列">三列</h4>
<p>三列语法与两列相似：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb7-1" title="1">::: 三栏</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3">::: 列</a>
<a class="sourceLine" id="cb7-4" title="4">左列。</a>
<a class="sourceLine" id="cb7-5" title="5">:::</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7">::: 列</a>
<a class="sourceLine" id="cb7-8" title="8">中列。</a>
<a class="sourceLine" id="cb7-9" title="9">:::</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11">::: 列</a>
<a class="sourceLine" id="cb7-12" title="12">右列。</a>
<a class="sourceLine" id="cb7-13" title="13">:::</a>
<a class="sourceLine" id="cb7-14" title="14"></a>
<a class="sourceLine" id="cb7-15" title="15">:::</a></code></pre></div>
<p>示例：</p>
<div class="提示">
<p>各个语言的“hello world”。</p>
<div class="三栏">
<div class="列">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- Haskell</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-3" title="3">main <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;hello world&quot;</span></a></code></pre></div>
</div>
<div class="列">
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="co">// javascript</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;hello world&quot;</span>)<span class="op">;</span></a></code></pre></div>
</div>
<div class="列">
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// rust</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb10-3" title="3">	<span class="pp">println!</span>(<span class="st">&quot;hello world&quot;</span>);</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="op">}</span></a></code></pre></div>
</div>
</div>
<p>我最喜C++。</p>
</div>
<h2 id="限制">限制</h2>
<h3 id="兼容性限制">兼容性限制</h3>
<p>普通浏览器（支持CSS渲染）的排版十分依赖CSS，该程序还要兼容终端的可阅读性，所以在HTML结构作出一些让步。在保证终端可读性的前提下，我们才会考虑提高网页排版能力，言下之意，优先保障终端，之后再考虑其他。</p>
<h3 id="标题等级限制">标题等级限制</h3>
<p>由于HTML5标准要发整个文档最多只有一个<code>&lt;h1&gt;</code>，本程序将它分配给文章标题，所以书写时最高只能使用二级标题。当然了，执意违反标准也是允许的。。</p>
<h3 id="文件名与标题">文件名与标题</h3>
<p>hakyll要求生成文件的名称格式为<code>&lt;年&gt;-&lt;月&gt;-&lt;日&gt;-&lt;文件名&gt;</code>，出于系统对中字兼容性的考虑，后面<code>&lt;文件名&gt;</code>并不作为文章的标题，它仅仅作为<em>文件名</em>使用，标题需要在文章里写明，可以不与文件名相同。本篇的标题如此写：</p>
<pre><code>-----
title: 中文书写简易说明
....
-----</code></pre>
<hr />
<p>参考材料：</p>
<ul>
<li>从《中文排版需求》开始: <a href="https://www.thetype.com/2015/04/9171/" class="uri">https://www.thetype.com/2015/04/9171/</a></li>
<li>「孔雀计划」序——中文排版思路的重建: <a href="https://www.thetype.com/2019/02/12498/" class="uri">https://www.thetype.com/2019/02/12498/</a></li>
</ul>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>
<entry>
    <title>HTTPure中间件</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/Purescript/2020-04-02-HTTPure%20Middleware.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/Purescript/2020-04-02-HTTPure%20Middleware.html</id>
    <published>2020-04-02T00:00:00Z</published>
    <updated>2020-04-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>HTTPure中间件</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../css/aono.css">
	<link rel="stylesheet" href="../../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../../index.html">首页</a></li>
				<li class="item"><a href="../../猫.html">分类</a></li>
				<li class="item"><a href="../../标签.html">标签</a></li>
			</ul>

			<a href="../../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				HTTPure中间件
				<small class="post date">
					-
					<time datetime="2020-04-02">2020年04月02日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../../%E6%A0%87%E7%AD%BE/purescript.html">purescript</a>, <a href="../../%E6%A0%87%E7%AD%BE/web.html">web</a>
		</header>
		<hr>
        <h1 id="httpure中间件">HTTPure中间件</h1>
<h2 id="中间件是什么">中间件是什么？</h2>
<p>中间件可以理解为“中间”处理过程，它有些类似于高阶函数。一个请求过来，除了正常路由处理，有时多处路由运用到同一个逻辑，我们不希望每次都 写一遍，那么可以利用中间件包裹，中间件中处理相同事件，之后决定是否要后续流程。 为了方便理解，我们从类型入手。一次正常请求，可以这样写：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">router ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span></a></code></pre></div>
<p>一个中间件，相当于可插拔硬件，当使用上该中间件时，请求依然可以正常运行，拿走也是一样。所以我们可以写出类型：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">middleware ::</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>)</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">-- 去除不必要的括号</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">middleware ::</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span></a></code></pre></div>
<p>很容易理解，<code>middleware</code>接受一个正常路由函数，返回一个新的路由函数，不同于<code>router</code>，<code>middleware</code>决定了要不要调用<code>router</code>。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">logMiddleware ::</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span>) <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span></a>
<a class="sourceLine" id="cb3-2" title="2">logMiddleware r request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" title="3">  liftEffect <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;before handle app&quot;</span></a>
<a class="sourceLine" id="cb3-4" title="4">  r' <span class="ot">&lt;-</span> r request</a>
<a class="sourceLine" id="cb3-5" title="5">  liftEffect <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;after handle app&quot;</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="fu">pure</span> r'</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="ot">app ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span></a>
<a class="sourceLine" id="cb3-9" title="9">app _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-10" title="10">  liftEffect <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;I'm app&quot;</span></a>
<a class="sourceLine" id="cb3-11" title="11">  ok <span class="st">&quot;hello&quot;</span></a>
<a class="sourceLine" id="cb3-12" title="12"></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="ot">main ::</span> <span class="dt">ServerM</span></a>
<a class="sourceLine" id="cb3-14" title="14">main <span class="fu">=</span> serve <span class="dv">3000</span> (logMiddleware app) <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;ok&quot;</span></a></code></pre></div>
<p><code>r' &lt;- r request</code>说明我们正常调用了<code>app</code>，我们访问任意地址就能得到以下结果：</p>
<blockquote>
<p>before handle app I’m app after handle app</p>
</blockquote>
<p>我们同样可以选择不调用<code>app</code>，只要改动一下<code>logMiddleware</code>：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">logMiddleware ::</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span>) <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span></a>
<a class="sourceLine" id="cb4-2" title="2">logMiddleware r request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" title="3">  liftEffect <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;before handle app&quot;</span></a>
<a class="sourceLine" id="cb4-4" title="4">  liftEffect <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;after handle app&quot;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  ok <span class="st">&quot;hello middleware&quot;</span></a></code></pre></div>
<p>结果：</p>
<blockquote>
<p>before handle app after handle app</p>
</blockquote>
<p><code>app</code>再无用处。</p>
<h2 id="中间件的组合">中间件的组合</h2>
<p>有了多个中间件，我们很自然想到组合它们。从签名来看——<code>(Request -&gt; Response) -&gt; (Request -&gt; Response)</code>——很好组合，<code>.</code>、<code>(&lt;&lt;&lt;)</code>就能搞定，需要注意的是组合方向，即调用顺序。</p>
<h2 id="中间件transformers">中间件transformers</h2>
<p>中间件说到底仅仅是个高阶函数，基于它，我们可以做一些常见操作，例如<code>ReaderT</code>，写大程序避免不了的部分。首先我们自定义自己的<code>ReaderT</code>：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">EnvT</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Int</span> <span class="dt">Aff</span></a></code></pre></div>
<p><code>EnvT</code>环境部分就是<code>Int</code>，实际代码可以换成数据库连接池等等。<code>Aff</code>表示允许异步操作，写js避免不了。除此之外，我们又该如何表示中间件呢？</p>
<p>从上面例子我们用到了<code>ResponseM</code>，查文档可以得到<code>type ResponseM = Aff Response</code>，<code>ResponseM</code>仅仅表示<code>Response</code>异步操作，这样就简单了，我们的<code>EnvT</code>已经包含了<code>Aff</code>，所以<code>app</code>可以这样改：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">app ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Response</span></a>
<a class="sourceLine" id="cb6-2" title="2">app _ <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" title="3">  s <span class="ot">&lt;-</span> asks <span class="fu">show</span></a>
<a class="sourceLine" id="cb6-4" title="4">  liftEffect <span class="fu">$</span> <span class="fu">log</span> s</a>
<a class="sourceLine" id="cb6-5" title="5">  ok s</a></code></pre></div>
<p><code>ResponseM</code>改成<code>EnvT Response</code>，原本意义没有改变，反而还多出额外属性。再回到中间件的写法，我们知道中间件第一个参数一般是<code>app</code>，返回一个新的应用（Application），所以我们可以这样写中间件：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">envMiddleware ::</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="fu">?</span></a></code></pre></div>
<p>结果就可多了，可以继续返回<code>EnvT Response</code>，或者<code>ResponseM</code>，但前者需要一个解包的过程，需要代入依赖环境才能得到真实的<code>Response</code>，我们不妨就在此处解包：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">envMiddleware ::</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span></a>
<a class="sourceLine" id="cb8-2" title="2">envMiddleware r request <span class="fu">=</span> runReaderT (r request) <span class="fu">?</span>x</a></code></pre></div>
<p>从编译器得知，<code>?x</code>的类型是<code>Int</code>，就是我们所缺的依赖环境，把它填入：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">envMiddleware ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">ResponseM</span></a>
<a class="sourceLine" id="cb9-2" title="2">envMiddleware x r request <span class="fu">=</span> runReaderT (r request) x</a></code></pre></div>
<p>调用它！</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">main ::</span> <span class="dt">ServerM</span></a>
<a class="sourceLine" id="cb10-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="kw">let</span> n <span class="fu">=</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb10-4" title="4">  serve <span class="dv">3000</span> (envMiddleware n app) <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;ok&quot;</span></a></code></pre></div>
<p>搞了这么多，最终还是回归“中间件就是一个高阶函数”，实际上我们可以直接写：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">main ::</span> <span class="dt">ServerM</span></a>
<a class="sourceLine" id="cb11-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="kw">let</span> n <span class="fu">=</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb11-4" title="4">  serve <span class="dv">3000</span> (\request <span class="ot">-&gt;</span> runReaderT (app request) n) <span class="fu">$</span> <span class="fu">log</span> <span class="st">&quot;ok&quot;</span></a></code></pre></div>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>
<entry>
    <title>racket/generic，另一种泛型</title>
    <link href="127.0.0.1/%E6%96%87%E7%AB%A0/Racket/2019-11-04-generic.html" />
    <id>127.0.0.1/%E6%96%87%E7%AB%A0/Racket/2019-11-04-generic.html</id>
    <published>2019-11-04T00:00:00Z</published>
    <updated>2019-11-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>racket/generic，另一种泛型</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../css/aono.css">
	<link rel="stylesheet" href="../../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../../index.html">首页</a></li>
				<li class="item"><a href="../../猫.html">分类</a></li>
				<li class="item"><a href="../../标签.html">标签</a></li>
			</ul>

			<a href="../../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				racket/generic，另一种泛型
				<small class="post date">
					-
					<time datetime="2019-11-04">2019年11月04日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../../%E6%A0%87%E7%AD%BE/json.html">json</a>, <a href="../../%E6%A0%87%E7%AD%BE/generic.html">generic</a>, <a href="../../%E6%A0%87%E7%AD%BE/racket.html">racket</a>
		</header>
		<hr>
        <h2 id="racketgeneric">racket/generic</h2>
<p><code>racket/generic</code>不在racket中，需要单独引入。它为每个类型提供相同方法，有点类似于接口。</p>
<p>为了简单说明使用方式，我们可以用它实现<code>ToJSON</code>。所谓<code>ToJSON</code>，就是定义一个<code>(-&gt;json)</code>函数，允许满足<code>ToJSON</code>类型的数据调用。</p>
<h2 id="define-generics定义接口">define-generics定义接口</h2>
<p>定义出这个方法：</p>
<pre class="racket"><code>(define-generics ToJSON
  (-&gt;json ToJSON)</code></pre>
<p>然后得到一个接口<code>gen:ToJSON</code>，一个函数方法<code>-&gt;json</code>，一个约束组合<code>ToJSON/c</code>，及<code>ToJSON?</code>检查函数。</p>
<h2 id="绑定到自定义struct">绑定到自定义struct</h2>
<p>我们先定义一个struct：</p>
<pre class="racket"><code>(struct person [id name])

;;; 再定义一个用例，方便测试。
(define me (person 1 &quot;haoren&quot;))</code></pre>
<p>我们这样是无法直接使用<code>-&gt;json</code>的，用过rust、haskell的人都知道，我们需要把接口与定义的类型组合起来，struct提供了<code>#:methods</code>参数，一个struct可以拥有多个<code>#:methods</code>。</p>
<p>改造一下person：</p>
<pre class="racket"><code>(struct person [id name]
  #:methods gen:ToJSON
  [(define (-&gt;json self)
	 (let ([o (make-hash `((id . ,(person-id self))
						   (name . ,(person-name self))))])
	   (jsexpr-&gt;string o)))])</code></pre>
<p>运行看看：</p>
<pre class="racket"><code>(-&gt;json me)
&quot;{\&quot;name\&quot;:\&quot;haoren\&quot;,\&quot;id\&quot;:1}&quot;</code></pre>
<h2 id="defaults绑定已存在类型">defaults，绑定已存在类型</h2>
<p>按理来说，<code>-&gt;json</code>也应该适用于像<code>number?</code>，<code>string?</code>这样的数据，我们再试它一试。</p>
<pre class="racket"><code>(-&gt;json &quot;sb&quot;)
; -&gt;json: not implemented for &quot;sb&quot;

(-&gt;json 1)
; -&gt;json: not implemented for 1</code></pre>
<p>不像话！新定义的struct可行，为何这几个基本类型就不行？！ 刚好<code>define-generics</code>提供<code>#:defaults</code>参数，<code>#:defaults</code>可以接受多组定义，定义的第一个是验证函数（pred?），如果满足该条件，就使用后面的定义，嗯，有点像<code>cond</code>和<code>match</code>。</p>
<p>我们为基本类型实现<code>-&gt;json</code>。</p>
<pre class="racket"><code>(define-generics ToJSON
  (-&gt;json ToJSON)
  #:defaults ([string? (define -&gt;json jsexpr-&gt;string)]
			  [number? (define -&gt;json jsexpr-&gt;string)]
			  [hash? (define -&gt;json jsexpr-&gt;string)]
			  [list? (define -&gt;json jsexpr-&gt;string)]))</code></pre>
<p>这时再试试看：</p>
<pre class="racket"><code>(-&gt;json 1)
&quot;1&quot;

(-&gt;json &quot;helle&quot;)
&quot;\&quot;helle\&quot;&quot;

(-&gt;json '(1 2 3))
&quot;[1,2,3]&quot;

(-&gt;json me)
&quot;{\&quot;name\&quot;:\&quot;haoren\&quot;,\&quot;id\&quot;:1}&quot;</code></pre>
<p>功成圆满。</p>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
]]></summary>
</entry>

</feed>
