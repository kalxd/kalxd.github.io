<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
	<title>关于运营后台动态模块权限设计方案的探索</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../../css/aono.css">
	<link rel="stylesheet" href="../../css/code.css">
	<link rel="shortcut icon" type="image/x-icon" href="../../image/favicon.ico">
</head>
<body>
	<main class="aono main container">
		<header class="aono site header">
			我的网站
			
		</header>
		<nav class="aono navi menu">
			<ul>
				<li class="item"><a href="../../index.html">首页</a></li>
				<li class="item"><a href="../../猫.html">分类</a></li>
				<li class="item"><a href="../../标签.html">标签</a></li>
			</ul>

			<a href="../../atom.xml" class="right item">订阅</a>
		</nav>

		<div class="aono segment">
			<article class="aono article">
    <section>
		<header class="header">
			<h1>
				关于运营后台动态模块权限设计方案的探索
				<small class="post date">
					-
					<time datetime="2020-07-07">2020年07月07日</time>
				</small>
			</h1>
		</header>
		<header class="cat">
			标签：<a href="../../%E6%A0%87%E7%AD%BE/Haskell.html">Haskell</a>, <a href="../../%E6%A0%87%E7%AD%BE/%E8%AE%BE%E8%AE%A1.html">设计</a>
		</header>
		<hr>
        <div class="toc">目录：<ul>
<li><a href="#摘要">摘要</a></li>
<li><a href="#背景">背景</a></li>
<li><a href="#整体设计">整体设计</a><ul>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#设计伪代码">设计伪代码</a></li>
<li><a href="#为前端考虑的scope">为前端考虑的scope</a></li>
</ul></li>
<li><a href="#实现网络服务">实现网络服务</a><ul>
<li><a href="#标识请求区分权限">标识请求、区分权限</a></li>
<li><a href="#路由表树">路由表（树）</a></li>
<li><a href="#router">Router</a></li>
<li><a href="#route">route</a></li>
<li><a href="#scope">scope</a></li>
<li><a href="#buildapp">buildApp</a></li>
<li><a href="#runserver">runServer</a></li>
</ul></li>
<li><a href="#实现权限树">实现权限树</a><ul>
<li><a href="#权限树">权限树</a></li>
<li><a href="#从路由到权限">从路由到权限</a></li>
<li><a href="#生成权限树">生成权限树</a></li>
</ul></li>
<li><a href="#结语">结语</a></li>
</ul></div><h2 id="摘要">摘要</h2>
<p>本文探索了一种可用于运营后台的动态权限设计方案，目的是为了避免以往繁琐的权限定义、权限判断。 从<em>请求</em>（<code>Request</code>）基本内容出发，把<code>URI</code>和<em>请求方式</em>（<code>Method</code>）作为权限的最小单元，直接对比得到权限判断结果。</p>
<h2 id="背景">背景</h2>
<p>公司内部都会有个让运营人员使用的后台系统，该系统往往涉及多个模块，每个人员、部门只操作自己那一部分。随着事务变理、增加、删减，往往会导致权限分配混乱不明、新旧代码难分难解。 手工定义每个模块、功能权限，一来难免会有遗漏，二来不容易统一管理。我们不妨改变一下原有思路，“权限”的出现是为了什么？“权限”本质上就是为了限制用户访问某个资源，那我们能不能直接从该资源入手？能否取消以前权限定义，以更直接方式处理？</p>
<p>假设有这么些个接口：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># 获取物品</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ex">GET</span> /item</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"># 更新物品</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ex">PUT</span> /item</a></code></pre></div>
<p>我们需要限定部分人访问，于是我们写下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> GET_ITEM_ROLE <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">const</span> PUT_TIME_ROLE <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> user <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-5" title="5">	<span class="cf">if</span> (<span class="va">user</span>.<span class="at">role</span> <span class="op">===</span> GET_ITEM_ROLE) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">		<span class="co">// 继续操作。</span></a>
<a class="sourceLine" id="cb2-7" title="7">	<span class="op">}</span></a>
<a class="sourceLine" id="cb2-8" title="8">	<span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-9" title="9">		<span class="co">// 无权访问。</span></a>
<a class="sourceLine" id="cb2-10" title="10">		<span class="at">status</span>(<span class="dv">403</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-11" title="11">	<span class="op">}</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">// PUT 相同逻辑。</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>写起来繁琐，我们可能会考虑利用中间件实现权限限制：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(GET_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(PUT_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>已经改观很多，但依然要指定<code>ROLE</code>，每次新增路由，都要再定义新<code>ROLE</code>，这样的样板代码已经无法消除掉了。 我们回过头来看<code>GET_ITEM_ROLE</code>和<code>PUT_ITEM_ROLE</code>，我们知道它们作用是为表明某个资源的访问权限，可以是任意值，假使让它们跟访问uri是同一个值会如何？我们改写上面的例子：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">const</span> GET_ITEM_ROLE <span class="op">=</span> <span class="st">&quot;/item&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">const</span> PUT_TIME_ROLE <span class="op">=</span> <span class="st">&quot;/item&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(GET_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(PUT_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>这样<code>GET_ITEM_ROLE</code>和<code>PUT_ITEM_ROLE</code>就没分别了，仔细想想，除了uri不同，还有区别就是<em>请求方式</em>（request method）不一样，一个是<code>GET</code>，另一个是<code>PUT</code>，把它们补充上去：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> GET_ITEM_ROLE <span class="op">=</span> [<span class="st">&quot;GET&quot;</span><span class="op">,</span> <span class="st">&quot;/item&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">const</span> PUT_TIME_ROLE <span class="op">=</span> [<span class="st">&quot;PUT&quot;</span><span class="op">,</span> <span class="st">&quot;/item&quot;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="va">app</span>.<span class="at">get</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(GET_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="va">app</span>.<span class="at">put</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> <span class="at">check</span>(PUT_ITEM_ROLE)<span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>再仔细观察，<code>method</code>和<code>uri</code>不就是能从<code>request</code>中取到的吗？何必再重新定义一遍？</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="va">app</span>.<span class="at">checkGet</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="va">app</span>.<span class="at">checkPut</span>(<span class="st">&quot;/item&quot;</span><span class="op">,</span> req <span class="kw">=&gt;</span> <span class="op">{</span>...<span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>换成这样的写法，将路由的定义和权限判断写在一起，不仅不会遗漏，而且不需要额外定义新变量——只管定义路由，权限的事自动处理掉。</p>
<p>这种设计另一个好处就是可以生成用户允许操作的菜单，由于路由在写代写完那一刻就已确定，同时已经用户拥有的权限（可能存在数据库），我们只需要构造出满足用户权限的路由表，输出到前端，渲染出来。同样减少前端工作量。</p>
<p>例如全部路由：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">|</span><span class="ex">-</span> /user</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">|</span>   <span class="kw">|</span><span class="ex">-</span> /view</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">|</span>	<span class="kw">|</span><span class="ex">-</span> /create</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">|</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">|</span><span class="ex">-</span> /item</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">|</span><span class="ex">-</span> /create</a></code></pre></div>
<p>某用户只有<code>/item</code>权限，最后他只能得到部分路由树：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">|</span><span class="ex">-</span> /item</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">|</span><span class="ex">-</span> /create</a></code></pre></div>
<p>这一切都是动态的。在路由定义好的那一刻就已确定！</p>
<h2 id="整体设计">整体设计</h2>
<div class="注意！">
<p>虽然重点在权限设计，但本文还是从最基础的网服服务开始搭建。 世面上网络服务框架基本不会收集所有路由信息，并能在路由内部直接获取，所以不得不重新建一个网络服务。 同时不涉及数据库存储、前端（GUI）等方面。</p>
</div>
<h3 id="haskell">Haskell</h3>
<p>演示语言选用Haskell，除了偏好外，它还有几个优点：</p>
<ul>
<li>有很多抽象概念，方便写DSL。</li>
<li>生态健康，方便写DSL。</li>
<li>方便写DSL。</li>
</ul>
<p>我们直接从<code>wai</code>（低层次的网络服务库）开始，本文仅仅是为探讨权限设计问题，焦点在<strong>权限</strong>上，不在框架上，所以很多地方——<code>params</code>解析等——就省略了。</p>
<h3 id="设计伪代码">设计伪代码</h3>
<p>选好了语言，接下来就是要设计目标，我们打算这样写路由和启动服务：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-2" title="2">    get <span class="st">&quot;/home&quot;</span> <span class="fu">$</span> text <span class="st">&quot;home&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3">    get <span class="st">&quot;/view&quot;</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-4" title="4">        tree <span class="ot">&lt;-</span> askPathTree</a>
<a class="sourceLine" id="cb9-5" title="5">        <span class="kw">let</span> xs <span class="fu">=</span> catMaybes <span class="fu">$</span> <span class="fu">map</span> (walkInPathTree tree) permission</a>
<a class="sourceLine" id="cb9-6" title="6">            tree' <span class="fu">=</span> <span class="fu">foldl</span> mergePathNode <span class="fu">mempty</span> xs</a>
<a class="sourceLine" id="cb9-7" title="7">        <span class="fu">pure</span> <span class="fu">$</span> string tree'</a>
<a class="sourceLine" id="cb9-8" title="8">    scope <span class="st">&quot;/user&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-9" title="9">        post <span class="st">&quot;/create&quot;</span> <span class="fu">$</span> text <span class="st">&quot;create user&quot;</span></a>
<a class="sourceLine" id="cb9-10" title="10">        get <span class="st">&quot;/user&quot;</span> <span class="fu">$</span> text <span class="st">&quot;get user&quot;</span></a>
<a class="sourceLine" id="cb9-11" title="11">        scope <span class="st">&quot;/vip&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-12" title="12">            get <span class="st">&quot;/user&quot;</span> <span class="fu">$</span> text <span class="st">&quot;vip user&quot;</span></a>
<a class="sourceLine" id="cb9-13" title="13"></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-15" title="15">main <span class="fu">=</span> runServer router</a></code></pre></div>
<p>排除<code>get &quot;/view&quot; ...</code>那块复杂的代码，其它部分都是定义了路由及相关操作。也就是我们先收集所有路由信息，然后对每一个请求做分发。</p>
<h3 id="为前端考虑的scope">为前端考虑的scope</h3>
<p>上述代码出现了三种定义路由的方式：<code>get</code>、<code>post</code>、<code>scope</code>。前两者容易理解，对于整个后端而言，也足够使用，但为何需要<code>scope</code>？ <code>scope</code>源自<a href="https://actix.rs/actix-web/actix_web/web/fn.scope.html">actix-web</a>，目的表示一个树结点，表示下面还有子结点。 最终整个路由展示出来的是一颗普通树，这颗树（根据用户权限生成）就是最终用户可操作菜单，前端只需要根据该结构渲染出菜单即可。</p>
<h2 id="实现网络服务">实现网络服务</h2>
<p>考虑到无关代码太多，不列出来又让人费解，所以最好边照<a href="https://github.com/kalxd/api-layout/blob/master/src/Lib.hs">源码</a>边往下看。</p>
<h3 id="标识请求区分权限">标识请求、区分权限</h3>
<p>上面讲到，仅有一个<code>uri</code>是无法区分哪条请求，也无法区分对应权限，还需要<code>method</code>。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">newtype</span> <span class="dt">XPath</span> <span class="fu">=</span> <span class="dt">XPath</span> {<span class="ot"> readPath ::</span> (<span class="dt">StdMethod</span>, <span class="dt">Path</span>) }</a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>一个<code>XPath</code>就是验证的最小单元。</p>
<h3 id="路由表树">路由表（树）</h3>
<p>回到上面伪代码那段代码，先不管如何收集这些路由，我们考虑一下保存到哪种数据结构里。很明显，为了方便前端渲染菜单，这个菜单一般是树型结构，那么结果自然要保存到树。以此为思路，我们将伪代码路由输出：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">|</span><span class="ex">-</span> (GET, /home)</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">|</span><span class="ex">-</span> (GET, /view)</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">|</span><span class="ex">-</span> /user</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="kw">|</span><span class="ex">-</span> (POST, /create)</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="kw">|</span><span class="ex">-</span> (GET, /user)</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="kw">|</span><span class="ex">-</span> /vip</a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="kw">|</span><span class="ex">-</span> (GET, /user)</a></code></pre></div>
<p>很明显看到结点有两种，一种就是<em>scope</em>，它处在中间，另一种就是叶子结点。那么我们先定义出结点类型：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">RouterNode</span> <span class="fu">=</span> <span class="dt">RouterLeaf</span> <span class="dt">XPath</span> <span class="dt">Handler</span></a>
<a class="sourceLine" id="cb12-2" title="2">                <span class="fu">|</span> <span class="dt">RouterScope</span> <span class="dt">Path</span> [<span class="dt">RouterNode</span>]</a></code></pre></div>
<p>那么树类型也就呼之欲出：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">data</span> <span class="dt">RouterTree</span> <span class="fu">=</span> <span class="dt">RouterTree</span> [<span class="dt">RouterNode</span>]</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">RouterTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" title="5">    (<span class="dt">RouterTree</span> xs) <span class="fu">&lt;&gt;</span> (<span class="dt">RouterTree</span> ys) <span class="fu">=</span> <span class="dt">RouterTree</span> <span class="fu">$</span> xs <span class="fu">&lt;&gt;</span> ys</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">RouterTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-8" title="8">    <span class="fu">mempty</span> <span class="fu">=</span> <span class="dt">RouterTree</span> <span class="fu">mempty</span></a></code></pre></div>
<p>这里实现幺半群实例，是为了后面路由的叠加作准备。</p>
<h3 id="router">Router</h3>
<p>我们再看这样的代码：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-2" title="2">    get <span class="st">&quot;/abc&quot;</span> <span class="fu">$</span> f</a>
<a class="sourceLine" id="cb14-3" title="3">	scope <span class="st">&quot;/scope&quot;</span></a>
<a class="sourceLine" id="cb14-4" title="4">	get <span class="st">&quot;/xyz&quot;</span></a></code></pre></div>
<p>省略掉<code>scope</code>后半部分，我们很容易得到它们类型接近——<code>T a</code>，只有<code>a</code>不确定。每次写<code>get</code>或<code>scope</code>都是往路由表里追加新路由，这种操作很容易想到<em>Writer</em>。</p>
<p>Router类型可以这么定义：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">type</span> <span class="dt">Router</span> <span class="fu">=</span> <span class="dt">WriterT</span> <span class="dt">RouterTree</span> <span class="dt">IO</span></a></code></pre></div>
<h3 id="route">route</h3>
<p><code>get</code>、<code>post</code>仅仅<code>method</code>不相同，我们可以抽出更通用方法：<code>route</code>。</p>
<p>由上可知，<code>route</code>最后也是要返回<code>Router a</code>：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">route ::</span> <span class="dt">StdMethod</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb16-2" title="2">route method path handler <span class="fu">=</span> tell <span class="fu">$</span> <span class="dt">RouterTree</span> [tree]</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="kw">where</span> tree <span class="fu">=</span> <span class="dt">RouterLeaf</span> xpath handler</a>
<a class="sourceLine" id="cb16-4" title="4">          xpath <span class="fu">=</span> <span class="dt">XPath</span> (method, path)</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co">-- 有了`route`，`get`、`post`都能容易实现。</span></a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="ot">get ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb16-9" title="9">get <span class="fu">=</span> route <span class="dt">GET</span></a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="ot">post ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb16-12" title="12">post <span class="fu">=</span> route <span class="dt">POST</span></a></code></pre></div>
<h3 id="scope">scope</h3>
<p>我们对比这两段代码：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="co">-- # 1</span></a>
<a class="sourceLine" id="cb17-2" title="2">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-3" title="3">    get <span class="st">&quot;/a&quot;</span></a>
<a class="sourceLine" id="cb17-4" title="4">    get <span class="st">&quot;/b&quot;</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co">-- # 2</span></a>
<a class="sourceLine" id="cb17-7" title="7">scope <span class="st">&quot;/x&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-8" title="8">    get <span class="st">&quot;/a&quot;</span></a>
<a class="sourceLine" id="cb17-9" title="9">    get <span class="st">&quot;/b&quot;</span></a></code></pre></div>
<p>十分相像，一个是根结点，一个是中间结点，处理差不是很多，唯一不同的是要追加到对应的地方：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">scope ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Router</span> a <span class="ot">-&gt;</span> <span class="dt">Router</span> a</a>
<a class="sourceLine" id="cb18-2" title="2">scope path <span class="fu">=</span> mapWriterT (<span class="fu">fmap</span> f)</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">where</span> f <span class="fu">=</span> <span class="fu">fmap</span> g</a>
<a class="sourceLine" id="cb18-4" title="4">          g (<span class="dt">RouterTree</span> xs) <span class="fu">=</span> <span class="dt">RouterTree</span> <span class="fu">$</span> [<span class="dt">RouterScope</span> path xs]</a></code></pre></div>
<h3 id="buildapp">buildApp</h3>
<p>我们已经收集到全部路由了，接下来就是做转发。<code>Network.Wai.Wrap.run</code>需要接受<code>Application</code>，在这里我们就要构造出来：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">buildApp ::</span> <span class="dt">RouterTree</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb19-2" title="2">buildApp tree req send <span class="fu">=</span> <span class="kw">case</span> handler <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-3" title="3">                            <span class="dt">Just</span> handler' <span class="ot">-&gt;</span> handler' req <span class="fu">&gt;&gt;=</span> send</a>
<a class="sourceLine" id="cb19-4" title="4">                            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> send <span class="fu">$</span> textResponse <span class="st">&quot;not found&quot;</span></a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="kw">where</span> path <span class="fu">=</span> rawPathInfo req</a>
<a class="sourceLine" id="cb19-6" title="6">          method <span class="fu">=</span> requestMethod req</a>
<a class="sourceLine" id="cb19-7" title="7">          handler <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-8" title="8">              method' <span class="ot">&lt;-</span> toStdMethod method</a>
<a class="sourceLine" id="cb19-9" title="9">              matchHandler method' path tree</a></code></pre></div>
<h3 id="runserver">runServer</h3>
<p>作为演示，我们默认3000端口。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="ot">runServer ::</span> <span class="dt">Router</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-2" title="2">runServer router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-3" title="3">    tree <span class="ot">&lt;-</span> execWriterT router</a>
<a class="sourceLine" id="cb20-4" title="4">    run <span class="dv">3000</span> <span class="fu">$</span> buildApp tree</a></code></pre></div>
<p>至此我们已经完成了所有工作，这已经是一个能做分发的网络服务框架。我们写段测试代码看看效果：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">router ::</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb21-2" title="2">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-3" title="3">    get <span class="st">&quot;/a&quot;</span> <span class="fu">$</span> text <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb21-4" title="4">	get <span class="st">&quot;/b&quot;</span> <span class="fu">$</span> text <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb21-5" title="5">	scope <span class="st">&quot;/f&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-6" title="6">	    get <span class="st">&quot;c&quot;</span> <span class="fu">$</span> text <span class="st">&quot;c&quot;</span></a>
<a class="sourceLine" id="cb21-7" title="7">		post <span class="st">&quot;d&quot;</span> <span class="fu">$</span> text <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-10" title="10">main <span class="fu">=</span> runServer router</a></code></pre></div>
<p>访问<em>localhost:3000/f/c</em>可以看到输出“c”。</p>
<h2 id="实现权限树">实现权限树</h2>
<p>目前为止，我们只实现最基本的网络服务，权限相关尚未涉及。 在设计之前，我们不妨想一想如何记录下用户的权限呢？以上面代码为例，假设用户可以访问<code>(GET, &quot;/a&quot;)</code>和<code>(POST, &quot;/f/d&quot;)</code>，用哪种结构最适宜？ 从树角度来看，它们没有共同根结点，虽然可以构造出虚拟根结点，但使用起来跟数组差不多，而且数组是多大存储服务支持的；从演示角度来讲，数组更方便些。</p>
<h3 id="权限树">权限树</h3>
<p>既然有了<a href="#路由表树">RouterTree</a>为什么还要再设计同样功能的树呢？ <code>RouterTree</code>除了记录路由之外，它还要保存<code>Handler</code>，我们说过前端菜单是由它生成的，<code>Handler</code>显然多余；它们除了记录路由以外，其他作用并不相同，处于不同范畴。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">data</span> <span class="dt">PathNode</span> <span class="fu">=</span> <span class="dt">PathScope</span> <span class="dt">Path</span> [<span class="dt">PathNode</span>]</a>
<a class="sourceLine" id="cb22-2" title="2">              <span class="fu">|</span> <span class="dt">PathLeaf</span> <span class="dt">XPath</span></a>
<a class="sourceLine" id="cb22-3" title="3">              <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="kw">data</span> <span class="dt">PathTree</span> <span class="fu">=</span> <span class="dt">PathTree</span> [<span class="dt">PathNode</span>]</a>
<a class="sourceLine" id="cb22-6" title="6">              <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb22-7" title="7"></a>
<a class="sourceLine" id="cb22-8" title="8"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">PathTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-9" title="9">    (<span class="dt">PathTree</span> xs) <span class="fu">&lt;&gt;</span> (<span class="dt">PathTree</span> ys) <span class="fu">=</span> <span class="dt">PathTree</span> <span class="fu">$</span> xs <span class="fu">&lt;&gt;</span> ys</a>
<a class="sourceLine" id="cb22-10" title="10"></a>
<a class="sourceLine" id="cb22-11" title="11"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">PathTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-12" title="12">    <span class="fu">mempty</span> <span class="fu">=</span> <span class="dt">PathTree</span> <span class="fu">mempty</span></a></code></pre></div>
<h3 id="从路由到权限">从路由到权限</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">router ::</span> <span class="dt">Router</span> ()</a>
<a class="sourceLine" id="cb23-2" title="2">router <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" title="3">    get <span class="st">&quot;/view&quot;</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-4" title="4">        tree <span class="ot">&lt;-</span> askPathTree</a>
<a class="sourceLine" id="cb23-5" title="5">        <span class="kw">let</span> xs <span class="fu">=</span> catMaybes <span class="fu">$</span> <span class="fu">map</span> (walkInPathTree tree) permission</a>
<a class="sourceLine" id="cb23-6" title="6">            tree' <span class="fu">=</span> <span class="fu">foldl</span> mergePathNode <span class="fu">mempty</span> xs</a>
<a class="sourceLine" id="cb23-7" title="7">        <span class="fu">pure</span> <span class="fu">$</span> string tree'</a></code></pre></div>
<p>这是伪代码中的一段，之前特意把这一段忽略，下面讲讲它的特殊之处。 这一整段代码最关键的是<code>askPathTree</code>，调用它会得到整颗权限树，特别就特别它处在<code>Handler</code>之中，单纯的<code>WriterT</code>无法预先得知所有信息，只有整段代码运行完才知晓。 这段代码恰巧处在上面，在静态语言中如何获取就成了关键。</p>
<p>根据直觉，路由收集在编译期可以直接得到，那么将结果保存到一个变量里，运行时再取出来不就解决了？于是我们使用IORef，创建一个全局变量。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">unsafePathTree ::</span> <span class="dt">IORef</span> <span class="dt">PathTree</span></a>
<a class="sourceLine" id="cb24-2" title="2">unsafePathTree <span class="fu">=</span> unsafePerformIO <span class="fu">$</span> newIORef <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="ot">askPathTree ::</span> <span class="dt">IO</span> <span class="dt">PathTree</span></a>
<a class="sourceLine" id="cb24-5" title="5">askPathTree <span class="fu">=</span> readIORef unsafePathTree</a></code></pre></div>
<p>全局变量不纯，所以是个IO操作。</p>
<p>再改造一下<code>runServer</code>，将结果保存下来：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb25-1" title="1">runServer :: Router a -&gt; IO ()</a>
<a class="sourceLine" id="cb25-2" title="2">runServer router = do</a>
<a class="sourceLine" id="cb25-3" title="3">    tree &lt;- execWriterT router</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="va">+   writeIORef unsafePathTree $ toPathTree tree</span></a>
<a class="sourceLine" id="cb25-5" title="5">    run 3000 $ buildApp tree</a></code></pre></div>
<h3 id="生成权限树">生成权限树</h3>
<p>差不多到最后几步了，回到开头，我们假设用户拥有如下权限：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">permission ::</span> [<span class="dt">XPath</span>]</a>
<a class="sourceLine" id="cb26-2" title="2">permission <span class="fu">=</span> [ <span class="dt">XPath</span> (<span class="dt">GET</span>, <span class="st">&quot;/home&quot;</span>) <span class="co">-- # 1</span></a>
<a class="sourceLine" id="cb26-3" title="3">             , <span class="dt">XPath</span> (<span class="dt">POST</span>, <span class="st">&quot;/home&quot;</span>) <span class="co">-- # 2</span></a>
<a class="sourceLine" id="cb26-4" title="4">             , <span class="dt">XPath</span> (<span class="dt">GET</span>, <span class="st">&quot;/user/vip/user&quot;</span>) <span class="co">-- # 3</span></a>
<a class="sourceLine" id="cb26-5" title="5">             ]</a></code></pre></div>
<p>很明显<em># 2</em>不存在，需要过滤。我们把合法权限输出：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">|</span><span class="ex">-</span> (GET, /home)      <span class="kw">|</span><span class="ex">-</span> /user</a>
<a class="sourceLine" id="cb27-2" title="2">                         <span class="kw">|</span><span class="ex">-</span> /vip</a>
<a class="sourceLine" id="cb27-3" title="3">                             <span class="kw">|</span><span class="ex">-</span> (GET, /user)</a></code></pre></div>
<p>将它们合在一起就是最后用户所能操作的所有权限了：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="fu">|-</span> (<span class="dt">GET</span>, <span class="fu">/</span>home)</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="fu">|-</span> <span class="fu">/</span>user</a>
<a class="sourceLine" id="cb28-3" title="3">    <span class="fu">|-</span> <span class="fu">/</span>vip</a>
<a class="sourceLine" id="cb28-4" title="4">        <span class="fu">|-</span> (<span class="dt">GET</span>, <span class="fu">/</span>user)</a></code></pre></div>
<p>同样的思路，我们依次取出每条权限树，最后作个合并：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="co">-- | 生成单条权限树。</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="ot">walkInPathTree ::</span> <span class="dt">PathTree</span> <span class="ot">-&gt;</span> <span class="dt">XPath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">PathNode</span></a>
<a class="sourceLine" id="cb29-3" title="3">walkInPathTree (<span class="dt">PathTree</span> xs) xpath<span class="fu">@</span>(<span class="dt">XPath</span> (method, path)) <span class="fu">=</span> asum <span class="fu">$</span> <span class="fu">map</span> f xs</a>
<a class="sourceLine" id="cb29-4" title="4">    <span class="kw">where</span> f node<span class="fu">@</span>(<span class="dt">PathLeaf</span> xpath') <span class="fu">=</span> <span class="kw">if</span> xpath <span class="fu">==</span> xpath'</a>
<a class="sourceLine" id="cb29-5" title="5">                                     <span class="kw">then</span> <span class="dt">Just</span> node</a>
<a class="sourceLine" id="cb29-6" title="6">                                     <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb29-7" title="7">          f (<span class="dt">PathScope</span> path' ys) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-8" title="8">              subpath <span class="ot">&lt;-</span> BS.stripPrefix path' path</a>
<a class="sourceLine" id="cb29-9" title="9">              child <span class="ot">&lt;-</span> walkInPathTree (<span class="dt">PathTree</span> ys) (<span class="dt">XPath</span> (method, subpath))</a>
<a class="sourceLine" id="cb29-10" title="10">              <span class="fu">pure</span> <span class="fu">$</span> <span class="dt">PathScope</span> path' <span class="fu">$</span> [child]</a>
<a class="sourceLine" id="cb29-11" title="11"></a>
<a class="sourceLine" id="cb29-12" title="12"><span class="co">-- | 合并</span></a>
<a class="sourceLine" id="cb29-13" title="13"><span class="ot">mergePathNode ::</span> <span class="dt">PathTree</span> <span class="ot">-&gt;</span> <span class="dt">PathNode</span> <span class="ot">-&gt;</span> <span class="dt">PathTree</span></a>
<a class="sourceLine" id="cb29-14" title="14">mergePathNode tree<span class="fu">@</span>(<span class="dt">PathTree</span> xs) node<span class="fu">@</span>(<span class="dt">PathLeaf</span> _)</a>
<a class="sourceLine" id="cb29-15" title="15">    <span class="fu">|</span> <span class="fu">elem</span> node xs <span class="fu">=</span> tree</a>
<a class="sourceLine" id="cb29-16" title="16">    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> tree <span class="fu">&lt;&gt;</span> <span class="dt">PathTree</span> [node]</a>
<a class="sourceLine" id="cb29-17" title="17">mergePathNode tree<span class="fu">@</span>(<span class="dt">PathTree</span> xs) node<span class="fu">@</span>(<span class="dt">PathScope</span> _ _) <span class="fu">=</span> <span class="kw">case</span> find (<span class="fu">==</span> node) xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-18" title="18">                                                            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> tree <span class="fu">&lt;&gt;</span> <span class="dt">PathTree</span> [node]</a>
<a class="sourceLine" id="cb29-19" title="19">                                                            <span class="dt">Just</span> node' <span class="ot">-&gt;</span> tree <span class="fu">&lt;&gt;</span> <span class="dt">PathTree</span> [f node' node]</a>
<a class="sourceLine" id="cb29-20" title="20">    <span class="kw">where</span> f scope<span class="fu">@</span>(<span class="dt">PathScope</span> method xs) (<span class="dt">PathScope</span> _ [x]) <span class="fu">=</span> <span class="dt">PathScope</span> method <span class="fu">$</span> pathTreeChildren <span class="fu">$</span> mergePathNode (<span class="dt">PathTree</span> xs) x</a></code></pre></div>
<div class="提示">
<p>总体实现粗糙，不停地打包、解包。</p>
<p>对比<code>RouterTree</code>和<code>PathTree</code>，它们仅仅是内部存储数据不同，我们可以单独抽出<code>Tree a b</code>，那么：</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="kw">data</span> <span class="dt">Tree</span> a b <span class="fu">=</span> <span class="dt">TreeLeaf</span> b</a>
<a class="sourceLine" id="cb30-3" title="3">              <span class="fu">|</span> <span class="dt">TreeNode</span> a [<span class="dt">Tree</span> a b]</a>
<a class="sourceLine" id="cb30-4" title="4"></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="kw">type</span> <span class="dt">RouterTree</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Path</span> (<span class="dt">XPath</span>, <span class="dt">Handler</span>)</a>
<a class="sourceLine" id="cb30-6" title="6"><span class="kw">type</span> <span class="dt">PathTree</span> <span class="fu">=</span> <span class="dt">Tree</span> <span class="dt">Path</span> <span class="dt">XPath</span></a></code></pre></div>
<p>不过这些都是后话，不在此处讨论的重点。</p>
</div>
<p>启动服务，查看<em>localhost:3000/view</em>就能看到该用户的权限树。</p>
<h2 id="结语">结语</h2>
<p>这套系统将以往权限定义与路由定义结合起来，在不影响原有业务逻辑前提下，依旧采用普通写法就能自动处理逻辑，从杂乱权限变量中解脱出来。生成的权限树，又能为前端提供渲染成菜单数据，也减少前端的工作量。</p>
<p>设计核心在于：当程序员编完路由后，整个程序能接受、不能接受哪些请求是十分确定的；权限之于用户，相当于是否授权访问某个路由。由此我们将路由信息与权限绑定，当新定义一条路由时，也相当于新定义一条权限。 代码组织上有层次结构，那么路由设计上也可以有层次，后台的侧边栏就是一个例子，一级菜单下有二级菜单，二级下有三级……我们再利用这种结构，将用户可访问的所有路由输出前端，由前端自动生成侧边栏菜单。</p>
<p>这些举措，后端新定义一个新路由，自动添加新权限，并自动更新前端侧边栏菜单。</p>
<p>这一套代码仅仅做了收集、过滤权限，用户权限分配、权限验证（过滤也能算一小部分）都未涉及； 前端菜单往往需要更多信息，单纯<code>PathTree</code>肯定无法满足。 如果做起来，差不多就要再造一个框架了。</p>
    </section>
</article>

		</div>

		<footer class="aono footer">
			本程序由
			<a href="https://jaspervdj.be/hakyll/">Hakyll</a>
			强力驱动！
		</footer>
	</main>
</body>
</html>
